(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_c_sharp"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
  "preprocessor_call";
]

let children_regexps : (string * Run.exp option) list = [
  "default_switch_label",
  Some (
    Seq [
      Token (Literal "default");
      Token (Literal ":");
    ];
  );
  "modifier",
  Some (
    Alt [|
      Token (Literal "abstract");
      Token (Literal "async");
      Token (Literal "const");
      Token (Literal "extern");
      Token (Literal "fixed");
      Token (Literal "internal");
      Token (Literal "new");
      Token (Literal "override");
      Token (Literal "partial");
      Token (Literal "private");
      Token (Literal "protected");
      Token (Literal "public");
      Token (Literal "readonly");
      Token (Literal "ref");
      Token (Literal "sealed");
      Token (Literal "static");
      Token (Literal "unsafe");
      Token (Literal "virtual");
      Token (Literal "volatile");
    |];
  );
  "verbatim_string_literal", None;
  "continue_statement",
  Some (
    Seq [
      Token (Literal "continue");
      Token (Literal ";");
    ];
  );
  "imm_tok_pat_684220d", None;
  "real_literal", None;
  "attribute_target_specifier",
  Some (
    Seq [
      Alt [|
        Token (Literal "field");
        Token (Literal "event");
        Token (Literal "method");
        Token (Literal "param");
        Token (Literal "property");
        Token (Literal "return");
        Token (Literal "type");
      |];
      Token (Literal ":");
    ];
  );
  "overloadable_operator",
  Some (
    Alt [|
      Token (Literal "!");
      Token (Literal "~");
      Token (Literal "++");
      Token (Literal "--");
      Token (Literal "true");
      Token (Literal "false");
      Token (Literal "+");
      Token (Literal "-");
      Token (Literal "*");
      Token (Literal "/");
      Token (Literal "%");
      Token (Literal "^");
      Token (Literal "|");
      Token (Literal "&");
      Token (Literal "<<");
      Token (Literal ">>");
      Token (Literal "==");
      Token (Literal "!=");
      Token (Literal ">");
      Token (Literal "<");
      Token (Literal ">=");
      Token (Literal "<=");
    |];
  );
  "constructor_constraint",
  Some (
    Seq [
      Token (Literal "new");
      Token (Literal "(");
      Token (Literal ")");
    ];
  );
  "pat_6d9db72", None;
  "parameter_modifier",
  Some (
    Alt [|
      Token (Literal "ref");
      Token (Literal "out");
      Token (Literal "this");
      Token (Literal "in");
    |];
  );
  "imm_tok_pat_2755817", None;
  "predefined_type", None;
  "pat_52ffbd7", None;
  "global", None;
  "this_expression", None;
  "discard", None;
  "void_keyword", None;
  "escape_sequence", None;
  "null_literal", None;
  "ellipsis", None;
  "reserved_identifier",
  Some (
    Alt [|
      Token (Literal "from");
    |];
  );
  "base_expression", None;
  "assignment_operator",
  Some (
    Alt [|
      Token (Literal "=");
      Token (Literal "+=");
      Token (Literal "-=");
      Token (Literal "*=");
      Token (Literal "/=");
      Token (Literal "%=");
      Token (Literal "&=");
      Token (Literal "^=");
      Token (Literal "|=");
      Token (Literal "<<=");
      Token (Literal ">>=");
      Token (Literal "??=");
    |];
  );
  "empty_statement", None;
  "identifier", None;
  "implicit_type", None;
  "break_statement",
  Some (
    Seq [
      Token (Literal "break");
      Token (Literal ";");
    ];
  );
  "imm_tok_pat_5a6fa79", None;
  "boolean_literal",
  Some (
    Alt [|
      Token (Literal "true");
      Token (Literal "false");
    |];
  );
  "integer_literal", None;
  "interpolated_verbatim_string_text",
  Some (
    Alt [|
      Token (Name "pat_6d9db72");
      Token (Literal "\"\"");
    |];
  );
  "interpolation_format_clause",
  Some (
    Seq [
      Token (Literal ":");
      Token (Name "pat_52ffbd7");
    ];
  );
  "interpolated_string_text",
  Some (
    Alt [|
      Token (Literal "{{");
      Token (Name "imm_tok_pat_2755817");
      Token (Name "escape_sequence");
    |];
  );
  "character_literal",
  Some (
    Seq [
      Token (Literal "'");
      Alt [|
        Token (Name "imm_tok_pat_684220d");
        Token (Name "escape_sequence");
      |];
      Token (Literal "'");
    ];
  );
  "extern_alias_directive",
  Some (
    Seq [
      Token (Literal "extern");
      Token (Literal "alias");
      Token (Name "identifier");
      Token (Literal ";");
    ];
  );
  "name_equals",
  Some (
    Seq [
      Alt [|
        Token (Name "global");
        Token (Name "identifier");
      |];
      Token (Literal "=");
    ];
  );
  "tuple_pattern",
  Some (
    Seq [
      Token (Literal "(");
      Alt [|
        Token (Name "identifier");
        Token (Name "discard");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "identifier");
            Token (Name "discard");
          |];
        ];
      );
      Token (Literal ")");
    ];
  );
  "join_into_clause",
  Some (
    Seq [
      Token (Literal "into");
      Token (Name "identifier");
    ];
  );
  "parenthesized_variable_designation",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "variable_designation");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "variable_designation");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "variable_designation",
  Some (
    Alt [|
      Token (Name "discard");
      Token (Name "parenthesized_variable_designation");
      Token (Name "identifier");
    |];
  );
  "name_colon",
  Some (
    Seq [
      Alt [|
        Token (Name "global");
        Token (Name "identifier");
      |];
      Token (Literal ":");
    ];
  );
  "string_literal",
  Some (
    Seq [
      Token (Literal "\"");
      Repeat (
        Alt [|
          Token (Name "imm_tok_pat_5a6fa79");
          Token (Name "escape_sequence");
        |];
      );
      Token (Literal "\"");
    ];
  );
  "var_pattern",
  Some (
    Seq [
      Token (Literal "var");
      Token (Name "variable_designation");
    ];
  );
  "literal",
  Some (
    Alt [|
      Token (Name "null_literal");
      Token (Name "boolean_literal");
      Token (Name "character_literal");
      Token (Name "real_literal");
      Token (Name "integer_literal");
      Token (Name "string_literal");
      Token (Name "verbatim_string_literal");
    |];
  );
  "alias_qualified_name",
  Some (
    Seq [
      Alt [|
        Token (Name "global");
        Token (Name "identifier");
      |];
      Token (Literal "::");
      Token (Name "simple_name");
    ];
  );
  "anonymous_method_expression",
  Some (
    Seq [
      Opt (
        Token (Literal "async");
      );
      Token (Literal "delegate");
      Opt (
        Token (Name "parameter_list");
      );
      Token (Name "block");
    ];
  );
  "anonymous_object_creation_expression",
  Some (
    Seq [
      Token (Literal "new");
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "anonymous_object_member_declarator");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "anonymous_object_member_declarator");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "anonymous_object_member_declarator",
  Some (
    Alt [|
      Seq [
        Token (Name "name_equals");
        Token (Name "expression");
      ];
      Token (Name "expression");
    |];
  );
  "argument",
  Some (
    Seq [
      Opt (
        Token (Name "name_colon");
      );
      Opt (
        Alt [|
          Token (Literal "ref");
          Token (Literal "out");
          Token (Literal "in");
        |];
      );
      Alt [|
        Token (Name "expression");
        Token (Name "declaration_expression");
      |];
    ];
  );
  "argument_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "argument");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "argument");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "array_creation_expression",
  Some (
    Seq [
      Token (Literal "new");
      Token (Name "array_type");
      Opt (
        Token (Name "initializer_expression");
      );
    ];
  );
  "array_rank_specifier",
  Some (
    Seq [
      Token (Literal "[");
      Opt (
        Seq [
          Opt (
            Token (Name "expression");
          );
          Repeat (
            Seq [
              Token (Literal ",");
              Opt (
                Token (Name "expression");
              );
            ];
          );
        ];
      );
      Token (Literal "]");
    ];
  );
  "array_type",
  Some (
    Seq [
      Token (Name "type");
      Token (Name "array_rank_specifier");
    ];
  );
  "arrow_expression_clause",
  Some (
    Seq [
      Token (Literal "=>");
      Token (Name "expression");
    ];
  );
  "assignment_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "assignment_operator");
      Token (Name "expression");
    ];
  );
  "attribute",
  Some (
    Seq [
      Token (Name "name");
      Opt (
        Token (Name "attribute_argument_list");
      );
    ];
  );
  "attribute_argument",
  Some (
    Seq [
      Opt (
        Alt [|
          Token (Name "name_equals");
          Token (Name "name_colon");
        |];
      );
      Token (Name "expression");
    ];
  );
  "attribute_argument_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "attribute_argument");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "attribute_argument");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "attribute_list",
  Some (
    Seq [
      Token (Literal "[");
      Opt (
        Token (Name "attribute_target_specifier");
      );
      Token (Name "attribute");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "attribute");
        ];
      );
      Token (Literal "]");
    ];
  );
  "await_expression",
  Some (
    Seq [
      Token (Literal "await");
      Token (Name "expression");
    ];
  );
  "binary_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Literal "&&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "||");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">>");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<<");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "^");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "|");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "+");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "-");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "*");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "/");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "%");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "==");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "??");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "is");
          Token (Literal "as");
        |];
        Token (Name "type");
      ];
    |];
  );
  "block",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "statement");
      );
      Token (Literal "}");
    ];
  );
  "bracketed_argument_list",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "argument");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "argument");
        ];
      );
      Token (Literal "]");
    ];
  );
  "case_pattern_switch_label",
  Some (
    Seq [
      Token (Literal "case");
      Token (Name "pattern");
      Opt (
        Token (Name "when_clause");
      );
      Token (Literal ":");
    ];
  );
  "case_switch_label",
  Some (
    Seq [
      Token (Literal "case");
      Token (Name "expression");
      Token (Literal ":");
    ];
  );
  "cast_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "type");
      Token (Literal ")");
      Token (Name "expression");
    ];
  );
  "catch_clause",
  Some (
    Seq [
      Token (Literal "catch");
      Opt (
        Token (Name "catch_declaration");
      );
      Opt (
        Token (Name "catch_filter_clause");
      );
      Token (Name "block");
    ];
  );
  "catch_declaration",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "type");
      Opt (
        Token (Name "identifier");
      );
      Token (Literal ")");
    ];
  );
  "catch_filter_clause",
  Some (
    Seq [
      Token (Literal "when");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "checked_expression",
  Some (
    Alt [|
      Seq [
        Token (Literal "checked");
        Token (Literal "(");
        Token (Name "expression");
        Token (Literal ")");
      ];
      Seq [
        Token (Literal "unchecked");
        Token (Literal "(");
        Token (Name "expression");
        Token (Literal ")");
      ];
    |];
  );
  "checked_statement",
  Some (
    Seq [
      Alt [|
        Token (Literal "checked");
        Token (Literal "unchecked");
      |];
      Token (Name "block");
    ];
  );
  "conditional_access_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "?");
      Token (Name "expression");
    ];
  );
  "conditional_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "?");
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "constant_pattern", Some (Token (Name "expression"););
  "declaration_expression",
  Some (
    Seq [
      Token (Name "type");
      Token (Name "identifier");
    ];
  );
  "declaration_pattern",
  Some (
    Seq [
      Token (Name "type");
      Token (Name "variable_designation");
    ];
  );
  "deep_ellipsis",
  Some (
    Seq [
      Token (Literal "<...");
      Token (Name "expression");
      Token (Literal "...>");
    ];
  );
  "default_expression",
  Some (
    Seq [
      Token (Literal "default");
      Opt (
        Seq [
          Token (Literal "(");
          Token (Name "type");
          Token (Literal ")");
        ];
      );
    ];
  );
  "do_statement",
  Some (
    Seq [
      Token (Literal "do");
      Token (Name "statement");
      Token (Literal "while");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Literal ";");
    ];
  );
  "element_access_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "bracketed_argument_list");
    ];
  );
  "element_binding_expression",
  Some (
    Token (Name "bracketed_argument_list");
  );
  "equals_value_clause",
  Some (
    Seq [
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "expression",
  Some (
    Alt [|
      Token (Name "anonymous_method_expression");
      Token (Name "anonymous_object_creation_expression");
      Token (Name "array_creation_expression");
      Token (Name "assignment_expression");
      Token (Name "await_expression");
      Token (Name "base_expression");
      Token (Name "binary_expression");
      Token (Name "cast_expression");
      Token (Name "checked_expression");
      Token (Name "conditional_access_expression");
      Token (Name "conditional_expression");
      Token (Name "default_expression");
      Token (Name "element_access_expression");
      Token (Name "element_binding_expression");
      Token (Name "implicit_array_creation_expression");
      Token (Name "implicit_stack_alloc_array_creation_expression");
      Token (Name "initializer_expression");
      Token (Name "interpolated_string_expression");
      Token (Name "invocation_expression");
      Token (Name "is_pattern_expression");
      Token (Name "lambda_expression");
      Token (Name "make_ref_expression");
      Token (Name "member_access_expression");
      Token (Name "member_binding_expression");
      Token (Name "object_creation_expression");
      Token (Name "parenthesized_expression");
      Token (Name "postfix_unary_expression");
      Token (Name "prefix_unary_expression");
      Token (Name "query_expression");
      Token (Name "range_expression");
      Token (Name "ref_expression");
      Token (Name "ref_type_expression");
      Token (Name "ref_value_expression");
      Token (Name "size_of_expression");
      Token (Name "stack_alloc_array_creation_expression");
      Token (Name "switch_expression");
      Token (Name "this_expression");
      Token (Name "throw_expression");
      Token (Name "tuple_expression");
      Token (Name "type_of_expression");
      Token (Name "simple_name");
      Token (Name "reserved_identifier");
      Token (Name "literal");
      Token (Name "ellipsis");
      Token (Name "deep_ellipsis");
    |];
  );
  "expression_statement",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Literal ";");
      ];
      Seq [
        Token (Name "ellipsis");
        Token (Literal ";");
      ];
      Token (Name "ellipsis");
    |];
  );
  "finally_clause",
  Some (
    Seq [
      Token (Literal "finally");
      Token (Name "block");
    ];
  );
  "fixed_statement",
  Some (
    Seq [
      Token (Literal "fixed");
      Token (Literal "(");
      Token (Name "variable_declaration");
      Token (Literal ")");
      Token (Name "statement");
    ];
  );
  "for_each_statement",
  Some (
    Seq [
      Opt (
        Token (Literal "await");
      );
      Token (Literal "foreach");
      Token (Literal "(");
      Alt [|
        Seq [
          Token (Name "type");
          Token (Name "identifier");
        ];
        Token (Name "expression");
      |];
      Token (Literal "in");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "statement");
    ];
  );
  "for_statement",
  Some (
    Seq [
      Token (Literal "for");
      Token (Literal "(");
      Opt (
        Alt [|
          Token (Name "variable_declaration");
          Seq [
            Token (Name "expression");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "expression");
              ];
            );
          ];
        |];
      );
      Token (Literal ";");
      Opt (
        Token (Name "expression");
      );
      Token (Literal ";");
      Opt (
        Seq [
          Token (Name "expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expression");
            ];
          );
        ];
      );
      Token (Literal ")");
      Token (Name "statement");
    ];
  );
  "formal_parameter_list",
  Some (
    Seq [
      Alt [|
        Token (Name "parameter");
        Token (Name "parameter_array");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "parameter");
            Token (Name "parameter_array");
          |];
        ];
      );
    ];
  );
  "from_clause",
  Some (
    Seq [
      Token (Literal "from");
      Opt (
        Token (Name "type");
      );
      Token (Name "identifier");
      Token (Literal "in");
      Token (Name "expression");
    ];
  );
  "function_body",
  Some (
    Alt [|
      Token (Name "block");
      Seq [
        Token (Name "arrow_expression_clause");
        Token (Literal ";");
      ];
      Token (Literal ";");
    |];
  );
  "generic_name",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Name "type_argument_list");
    ];
  );
  "goto_statement",
  Some (
    Seq [
      Token (Literal "goto");
      Alt [|
        Token (Name "identifier");
        Seq [
          Token (Literal "case");
          Token (Name "expression");
        ];
        Token (Literal "default");
      |];
      Token (Literal ";");
    ];
  );
  "group_clause",
  Some (
    Seq [
      Token (Literal "group");
      Token (Name "expression");
      Token (Literal "by");
      Token (Name "expression");
    ];
  );
  "if_statement",
  Some (
    Seq [
      Token (Literal "if");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "statement");
      Opt (
        Seq [
          Token (Literal "else");
          Token (Name "statement");
        ];
      );
    ];
  );
  "implicit_array_creation_expression",
  Some (
    Seq [
      Token (Literal "new");
      Token (Literal "[");
      Repeat (
        Token (Literal ",");
      );
      Token (Literal "]");
      Token (Name "initializer_expression");
    ];
  );
  "implicit_stack_alloc_array_creation_expression",
  Some (
    Seq [
      Token (Literal "stackalloc");
      Token (Literal "[");
      Token (Literal "]");
      Token (Name "initializer_expression");
    ];
  );
  "initializer_expression",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expression");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "interpolated_string_content",
  Some (
    Alt [|
      Token (Name "interpolated_string_text");
      Token (Name "interpolation");
    |];
  );
  "interpolated_string_expression",
  Some (
    Alt [|
      Seq [
        Token (Literal "$\"");
        Repeat (
          Token (Name "interpolated_string_content");
        );
        Token (Literal "\"");
      ];
      Seq [
        Token (Literal "$@\"");
        Repeat (
          Token (Name "interpolated_verbatim_string_content");
        );
        Token (Literal "\"");
      ];
    |];
  );
  "interpolated_verbatim_string_content",
  Some (
    Alt [|
      Token (Name "interpolated_verbatim_string_text");
      Token (Name "interpolation");
    |];
  );
  "interpolation",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "expression");
      Opt (
        Token (Name "interpolation_alignment_clause");
      );
      Opt (
        Token (Name "interpolation_format_clause");
      );
      Token (Literal "}");
    ];
  );
  "interpolation_alignment_clause",
  Some (
    Seq [
      Token (Literal ",");
      Token (Name "expression");
    ];
  );
  "invocation_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "argument_list");
    ];
  );
  "is_pattern_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "is");
      Token (Name "pattern");
    ];
  );
  "join_clause",
  Some (
    Seq [
      Token (Literal "join");
      Opt (
        Token (Name "type");
      );
      Token (Name "identifier");
      Token (Literal "in");
      Token (Name "expression");
      Token (Literal "on");
      Token (Name "expression");
      Token (Literal "equals");
      Token (Name "expression");
      Opt (
        Token (Name "join_into_clause");
      );
    ];
  );
  "labeled_statement",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal ":");
      Token (Name "statement");
    ];
  );
  "lambda_expression",
  Some (
    Seq [
      Opt (
        Token (Literal "async");
      );
      Alt [|
        Token (Name "parameter_list");
        Token (Name "identifier");
      |];
      Token (Literal "=>");
      Alt [|
        Token (Name "block");
        Token (Name "expression");
      |];
    ];
  );
  "let_clause",
  Some (
    Seq [
      Token (Literal "let");
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "local_declaration_statement",
  Some (
    Seq [
      Opt (
        Token (Literal "await");
      );
      Opt (
        Token (Literal "using");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Name "variable_declaration");
      Token (Literal ";");
    ];
  );
  "local_function_statement",
  Some (
    Seq [
      Repeat (
        Token (Name "modifier");
      );
      Alt [|
        Token (Name "type");
        Token (Name "void_keyword");
      |];
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameter_list");
      );
      Token (Name "parameter_list");
      Repeat (
        Token (Name "type_parameter_constraints_clause");
      );
      Token (Name "function_body");
    ];
  );
  "lock_statement",
  Some (
    Seq [
      Token (Literal "lock");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "statement");
    ];
  );
  "make_ref_expression",
  Some (
    Seq [
      Token (Literal "__makeref");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "member_access_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "expression");
        Token (Name "type");
        Token (Name "name");
      |];
      Alt [|
        Token (Literal ".");
        Token (Literal "->");
      |];
      Token (Name "simple_name");
    ];
  );
  "member_binding_expression",
  Some (
    Seq [
      Token (Literal ".");
      Token (Name "simple_name");
    ];
  );
  "name",
  Some (
    Alt [|
      Token (Name "alias_qualified_name");
      Token (Name "qualified_name");
      Token (Name "simple_name");
    |];
  );
  "nullable_type",
  Some (
    Alt [|
      Seq [
        Token (Name "type");
        Token (Literal "?");
      ];
    |];
  );
  "object_creation_expression",
  Some (
    Seq [
      Token (Literal "new");
      Token (Name "type");
      Opt (
        Token (Name "argument_list");
      );
      Opt (
        Token (Name "initializer_expression");
      );
    ];
  );
  "order_by_clause",
  Some (
    Seq [
      Token (Literal "orderby");
      Token (Name "ordering");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "ordering");
        ];
      );
    ];
  );
  "ordering",
  Some (
    Seq [
      Token (Name "expression");
      Opt (
        Alt [|
          Token (Literal "ascending");
          Token (Literal "descending");
        |];
      );
    ];
  );
  "parameter",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Opt (
        Token (Name "parameter_modifier");
      );
      Opt (
        Token (Name "type");
      );
      Token (Name "identifier");
      Opt (
        Token (Name "equals_value_clause");
      );
    ];
  );
  "parameter_array",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Token (Literal "params");
      Token (Name "array_type");
      Token (Name "identifier");
    ];
  );
  "parameter_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Token (Name "formal_parameter_list");
      );
      Token (Literal ")");
    ];
  );
  "parenthesized_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "pattern",
  Some (
    Alt [|
      Token (Name "constant_pattern");
      Token (Name "declaration_pattern");
      Token (Name "discard");
      Token (Name "var_pattern");
    |];
  );
  "pointer_type",
  Some (
    Seq [
      Token (Name "type");
      Token (Literal "*");
    ];
  );
  "postfix_unary_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Literal "++");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "--");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!");
      ];
    |];
  );
  "prefix_unary_expression",
  Some (
    Alt [|
      Seq [
        Token (Literal "!");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "&");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "*");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "+");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "++");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "-");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "--");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "^");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "~");
        Token (Name "expression");
      ];
    |];
  );
  "qualified_name",
  Some (
    Seq [
      Token (Name "name");
      Token (Literal ".");
      Token (Name "simple_name");
    ];
  );
  "query_body",
  Some (
    Alt [|
      Seq [
        Repeat (
          Token (Name "query_clause");
        );
        Token (Name "select_or_group_clause");
        Opt (
          Token (Name "query_continuation");
        );
      ];
    |];
  );
  "query_clause",
  Some (
    Alt [|
      Token (Name "from_clause");
      Token (Name "join_clause");
      Token (Name "let_clause");
      Token (Name "order_by_clause");
      Token (Name "where_clause");
    |];
  );
  "query_continuation",
  Some (
    Alt [|
      Seq [
        Token (Literal "into");
        Token (Name "identifier");
        Token (Name "query_body");
      ];
    |];
  );
  "query_expression",
  Some (
    Seq [
      Token (Name "from_clause");
      Token (Name "query_body");
    ];
  );
  "range_expression",
  Some (
    Seq [
      Opt (
        Token (Name "expression");
      );
      Token (Literal "..");
      Opt (
        Token (Name "expression");
      );
    ];
  );
  "ref_expression",
  Some (
    Seq [
      Token (Literal "ref");
      Token (Name "expression");
    ];
  );
  "ref_type_expression",
  Some (
    Seq [
      Token (Literal "__reftype");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "ref_value_expression",
  Some (
    Seq [
      Token (Literal "__refvalue");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ",");
      Token (Name "type");
      Token (Literal ")");
    ];
  );
  "return_statement",
  Some (
    Seq [
      Token (Literal "return");
      Opt (
        Token (Name "expression");
      );
      Token (Literal ";");
    ];
  );
  "select_clause",
  Some (
    Seq [
      Token (Literal "select");
      Token (Name "expression");
    ];
  );
  "select_or_group_clause",
  Some (
    Alt [|
      Token (Name "group_clause");
      Token (Name "select_clause");
    |];
  );
  "simple_name",
  Some (
    Alt [|
      Token (Name "generic_name");
      Alt [|
        Token (Name "global");
        Token (Name "identifier");
      |];
    |];
  );
  "size_of_expression",
  Some (
    Seq [
      Token (Literal "sizeof");
      Token (Literal "(");
      Token (Name "type");
      Token (Literal ")");
    ];
  );
  "stack_alloc_array_creation_expression",
  Some (
    Seq [
      Token (Literal "stackalloc");
      Token (Name "array_type");
      Opt (
        Token (Name "initializer_expression");
      );
    ];
  );
  "statement",
  Some (
    Alt [|
      Token (Name "block");
      Token (Name "break_statement");
      Token (Name "checked_statement");
      Token (Name "continue_statement");
      Token (Name "do_statement");
      Token (Name "empty_statement");
      Token (Name "expression_statement");
      Token (Name "fixed_statement");
      Token (Name "for_each_statement");
      Token (Name "for_statement");
      Token (Name "goto_statement");
      Token (Name "if_statement");
      Token (Name "labeled_statement");
      Token (Name "local_declaration_statement");
      Token (Name "local_function_statement");
      Token (Name "lock_statement");
      Token (Name "return_statement");
      Token (Name "switch_statement");
      Token (Name "throw_statement");
      Token (Name "try_statement");
      Token (Name "unsafe_statement");
      Token (Name "using_statement");
      Token (Name "while_statement");
      Token (Name "yield_statement");
    |];
  );
  "switch_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "switch_section");
      );
      Token (Literal "}");
    ];
  );
  "switch_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "switch");
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "switch_expression_arm");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "switch_expression_arm");
            ];
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "switch_expression_arm",
  Some (
    Seq [
      Token (Name "pattern");
      Opt (
        Token (Name "when_clause");
      );
      Token (Literal "=>");
      Token (Name "expression");
    ];
  );
  "switch_section",
  Some (
    Seq [
      Repeat1 (
        Alt [|
          Token (Name "case_switch_label");
          Token (Name "case_pattern_switch_label");
          Token (Name "default_switch_label");
        |];
      );
      Repeat1 (
        Token (Name "statement");
      );
    ];
  );
  "switch_statement",
  Some (
    Seq [
      Token (Literal "switch");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "switch_body");
    ];
  );
  "throw_expression",
  Some (
    Seq [
      Token (Literal "throw");
      Token (Name "expression");
    ];
  );
  "throw_statement",
  Some (
    Seq [
      Token (Literal "throw");
      Opt (
        Token (Name "expression");
      );
      Token (Literal ";");
    ];
  );
  "try_statement",
  Some (
    Seq [
      Token (Literal "try");
      Token (Name "block");
      Repeat (
        Token (Name "catch_clause");
      );
      Opt (
        Token (Name "finally_clause");
      );
    ];
  );
  "tuple_element",
  Some (
    Seq [
      Token (Name "type");
      Opt (
        Token (Name "identifier");
      );
    ];
  );
  "tuple_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "argument");
      Repeat1 (
        Seq [
          Token (Literal ",");
          Token (Name "argument");
        ];
      );
      Token (Literal ")");
    ];
  );
  "tuple_type",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "tuple_element");
      Repeat1 (
        Seq [
          Token (Literal ",");
          Token (Name "tuple_element");
        ];
      );
      Token (Literal ")");
    ];
  );
  "type",
  Some (
    Alt [|
      Token (Name "implicit_type");
      Token (Name "array_type");
      Token (Name "name");
      Token (Name "nullable_type");
      Token (Name "pointer_type");
      Token (Name "predefined_type");
      Token (Name "tuple_type");
    |];
  );
  "type_argument_list",
  Some (
    Seq [
      Token (Literal "<");
      Alt [|
        Repeat (
          Token (Literal ",");
        );
        Seq [
          Token (Name "type");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "type");
            ];
          );
        ];
      |];
      Token (Literal ">");
    ];
  );
  "type_constraint", Some (Token (Name "type"););
  "type_of_expression",
  Some (
    Seq [
      Token (Literal "typeof");
      Token (Literal "(");
      Token (Name "type");
      Token (Literal ")");
    ];
  );
  "type_parameter",
  Some (
    Seq [
      Opt (
        Token (Name "attribute_list");
      );
      Opt (
        Alt [|
          Token (Literal "in");
          Token (Literal "out");
        |];
      );
      Token (Name "identifier");
    ];
  );
  "type_parameter_constraint",
  Some (
    Alt [|
      Token (Literal "class");
      Token (Literal "struct");
      Token (Literal "unmanaged");
      Token (Name "constructor_constraint");
      Token (Name "type_constraint");
    |];
  );
  "type_parameter_constraints_clause",
  Some (
    Seq [
      Token (Literal "where");
      Alt [|
        Token (Name "global");
        Token (Name "identifier");
      |];
      Token (Literal ":");
      Token (Name "type_parameter_constraint");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type_parameter_constraint");
        ];
      );
    ];
  );
  "type_parameter_list",
  Some (
    Seq [
      Token (Literal "<");
      Token (Name "type_parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type_parameter");
        ];
      );
      Token (Literal ">");
    ];
  );
  "unsafe_statement",
  Some (
    Seq [
      Token (Literal "unsafe");
      Token (Name "block");
    ];
  );
  "using_statement",
  Some (
    Seq [
      Opt (
        Token (Literal "await");
      );
      Token (Literal "using");
      Token (Literal "(");
      Alt [|
        Token (Name "variable_declaration");
        Token (Name "expression");
      |];
      Token (Literal ")");
      Token (Name "statement");
    ];
  );
  "variable_declaration",
  Some (
    Seq [
      Token (Name "type");
      Token (Name "variable_declarator");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "variable_declarator");
        ];
      );
    ];
  );
  "variable_declarator",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "tuple_pattern");
      |];
      Opt (
        Token (Name "bracketed_argument_list");
      );
      Opt (
        Token (Name "equals_value_clause");
      );
    ];
  );
  "when_clause",
  Some (
    Seq [
      Token (Literal "when");
      Token (Name "expression");
    ];
  );
  "where_clause",
  Some (
    Seq [
      Token (Literal "where");
      Token (Name "expression");
    ];
  );
  "while_statement",
  Some (
    Seq [
      Token (Literal "while");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "statement");
    ];
  );
  "yield_statement",
  Some (
    Seq [
      Token (Literal "yield");
      Alt [|
        Seq [
          Token (Literal "return");
          Token (Name "expression");
        ];
        Token (Literal "break");
      |];
      Token (Literal ";");
    ];
  );
  "conversion_operator_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Alt [|
        Token (Literal "implicit");
        Token (Literal "explicit");
      |];
      Token (Literal "operator");
      Token (Name "type");
      Token (Name "parameter_list");
      Token (Name "function_body");
    ];
  );
  "event_field_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Literal "event");
      Token (Name "variable_declaration");
      Token (Literal ";");
    ];
  );
  "base_list",
  Some (
    Seq [
      Token (Literal ":");
      Token (Name "type");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type");
        ];
      );
    ];
  );
  "explicit_interface_specifier",
  Some (
    Seq [
      Token (Name "name");
      Token (Literal ".");
    ];
  );
  "bracketed_parameter_list",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "parameter");
        ];
      );
      Token (Literal "]");
    ];
  );
  "operator_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Name "type");
      Token (Literal "operator");
      Token (Name "overloadable_operator");
      Token (Name "parameter_list");
      Token (Name "function_body");
    ];
  );
  "using_directive",
  Some (
    Seq [
      Token (Literal "using");
      Opt (
        Alt [|
          Token (Literal "static");
          Token (Name "name_equals");
        |];
      );
      Token (Name "name");
      Token (Literal ";");
    ];
  );
  "constructor_initializer",
  Some (
    Seq [
      Token (Literal ":");
      Alt [|
        Token (Literal "base");
        Token (Literal "this");
      |];
      Token (Name "argument_list");
    ];
  );
  "semgrep_expression",
  Some (
    Seq [
      Token (Literal "__SEMGREP_EXPRESSION");
      Token (Name "expression");
    ];
  );
  "destructor_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Opt (
        Token (Literal "extern");
      );
      Token (Literal "~");
      Token (Name "identifier");
      Token (Name "parameter_list");
      Token (Name "function_body");
    ];
  );
  "field_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Name "variable_declaration");
      Token (Literal ";");
    ];
  );
  "enum_member_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
    ];
  );
  "accessor_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Alt [|
        Token (Literal "get");
        Token (Literal "set");
        Token (Literal "add");
        Token (Literal "remove");
        Token (Name "identifier");
      |];
      Token (Name "function_body");
    ];
  );
  "global_attribute_list",
  Some (
    Seq [
      Token (Literal "[");
      Alt [|
        Token (Literal "assembly");
        Token (Literal "module");
      |];
      Token (Literal ":");
      Opt (
        Seq [
          Token (Name "attribute");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "attribute");
            ];
          );
        ];
      );
      Token (Literal "]");
    ];
  );
  "delegate_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Literal "delegate");
      Alt [|
        Token (Name "type");
        Token (Name "void_keyword");
      |];
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameter_list");
      );
      Token (Name "parameter_list");
      Repeat (
        Token (Name "type_parameter_constraints_clause");
      );
      Token (Literal ";");
    ];
  );
  "method_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Alt [|
        Token (Name "type");
        Token (Name "void_keyword");
      |];
      Opt (
        Token (Name "explicit_interface_specifier");
      );
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameter_list");
      );
      Token (Name "parameter_list");
      Repeat (
        Token (Name "type_parameter_constraints_clause");
      );
      Token (Name "function_body");
    ];
  );
  "constructor_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Name "identifier");
      Token (Name "parameter_list");
      Opt (
        Token (Name "constructor_initializer");
      );
      Token (Name "function_body");
    ];
  );
  "enum_member_declaration_list",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "enum_member_declaration");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "enum_member_declaration");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "accessor_list",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "accessor_declaration");
      );
      Token (Literal "}");
    ];
  );
  "enum_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Literal "enum");
      Token (Name "identifier");
      Opt (
        Token (Name "base_list");
      );
      Token (Name "enum_member_declaration_list");
      Opt (
        Token (Literal ";");
      );
    ];
  );
  "property_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Name "type");
      Opt (
        Token (Name "explicit_interface_specifier");
      );
      Token (Name "identifier");
      Alt [|
        Seq [
          Token (Name "accessor_list");
          Opt (
            Seq [
              Token (Literal "=");
              Token (Name "expression");
              Token (Literal ";");
            ];
          );
        ];
        Seq [
          Token (Name "arrow_expression_clause");
          Token (Literal ";");
        ];
      |];
    ];
  );
  "indexer_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Name "type");
      Opt (
        Token (Name "explicit_interface_specifier");
      );
      Token (Literal "this");
      Token (Name "bracketed_parameter_list");
      Alt [|
        Token (Name "accessor_list");
        Seq [
          Token (Name "arrow_expression_clause");
          Token (Literal ";");
        ];
      |];
    ];
  );
  "event_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Literal "event");
      Token (Name "type");
      Opt (
        Token (Name "explicit_interface_specifier");
      );
      Token (Name "identifier");
      Alt [|
        Token (Name "accessor_list");
        Token (Literal ";");
      |];
    ];
  );
  "class_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Literal "class");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameter_list");
      );
      Opt (
        Token (Name "base_list");
      );
      Repeat (
        Token (Name "type_parameter_constraints_clause");
      );
      Token (Name "declaration_list");
      Opt (
        Token (Literal ";");
      );
    ];
  );
  "declaration",
  Some (
    Alt [|
      Token (Name "global_attribute_list");
      Token (Name "class_declaration");
      Token (Name "constructor_declaration");
      Token (Name "conversion_operator_declaration");
      Token (Name "delegate_declaration");
      Token (Name "destructor_declaration");
      Token (Name "enum_declaration");
      Token (Name "event_declaration");
      Token (Name "extern_alias_directive");
      Token (Name "event_field_declaration");
      Token (Name "field_declaration");
      Token (Name "indexer_declaration");
      Token (Name "interface_declaration");
      Token (Name "method_declaration");
      Token (Name "namespace_declaration");
      Token (Name "operator_declaration");
      Token (Name "property_declaration");
      Token (Name "struct_declaration");
      Token (Name "using_directive");
    |];
  );
  "declaration_list",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "declaration");
      );
      Token (Literal "}");
    ];
  );
  "interface_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Literal "interface");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameter_list");
      );
      Opt (
        Token (Name "base_list");
      );
      Repeat (
        Token (Name "type_parameter_constraints_clause");
      );
      Token (Name "declaration_list");
      Opt (
        Token (Literal ";");
      );
    ];
  );
  "namespace_declaration",
  Some (
    Seq [
      Token (Literal "namespace");
      Token (Name "name");
      Token (Name "declaration_list");
      Opt (
        Token (Literal ";");
      );
    ];
  );
  "struct_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "attribute_list");
      );
      Repeat (
        Token (Name "modifier");
      );
      Token (Literal "struct");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameter_list");
      );
      Opt (
        Token (Name "base_list");
      );
      Repeat (
        Token (Name "type_parameter_constraints_clause");
      );
      Token (Name "declaration_list");
      Opt (
        Token (Literal ";");
      );
    ];
  );
  "compilation_unit",
  Some (
    Alt [|
      Repeat (
        Token (Name "declaration");
      );
      Token (Name "semgrep_expression");
    |];
  );
]

let trans_default_switch_label ((kind, body) : mt) : CST.default_switch_label =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_modifier ((kind, body) : mt) : CST.modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Abst (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Async (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Const (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Extern (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Fixed (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Inte (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `New (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Over (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Part (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Priv (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Prot (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Public (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Read (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Ref (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Sealed (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Static (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Unsafe (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Virt (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Vola (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_verbatim_string_literal ((kind, body) : mt) : CST.verbatim_string_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_continue_statement ((kind, body) : mt) : CST.continue_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_imm_tok_pat_684220d ((kind, body) : mt) : CST.imm_tok_pat_684220d =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_real_literal ((kind, body) : mt) : CST.real_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_attribute_target_specifier ((kind, body) : mt) : CST.attribute_target_specifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Field (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Event (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Meth (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Param (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Prop (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Ret (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Type (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_overloadable_operator ((kind, body) : mt) : CST.overloadable_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `BANG (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `TILDE (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `PLUSPLUS (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `DASHDASH (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `True (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `False (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `PLUS (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `DASH (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `STAR (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `SLASH (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `PERC (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `HAT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `BAR (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `AMP (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `LTLT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `GTGT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `EQEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `BANGEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `GT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `LT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `GTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `LTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_constructor_constraint ((kind, body) : mt) : CST.constructor_constraint =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_6d9db72 ((kind, body) : mt) : CST.pat_6d9db72 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_parameter_modifier ((kind, body) : mt) : CST.parameter_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Ref (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Out (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `This (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `In (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_imm_tok_pat_2755817 ((kind, body) : mt) : CST.imm_tok_pat_2755817 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_predefined_type ((kind, body) : mt) : CST.predefined_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_pat_52ffbd7 ((kind, body) : mt) : CST.pat_52ffbd7 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_global ((kind, body) : mt) : CST.global =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_this_expression ((kind, body) : mt) : CST.this_expression =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_discard ((kind, body) : mt) : CST.discard =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_void_keyword ((kind, body) : mt) : CST.void_keyword =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_null_literal ((kind, body) : mt) : CST.null_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_ellipsis ((kind, body) : mt) : CST.ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_reserved_identifier ((kind, body) : mt) : CST.reserved_identifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `From (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_base_expression ((kind, body) : mt) : CST.base_expression =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_assignment_operator ((kind, body) : mt) : CST.assignment_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `EQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `PLUSEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `DASHEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `STAREQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `SLASHEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `PERCEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `AMPEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `HATEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `BAREQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `LTLTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `GTGTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `QMARKQMARKEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_empty_statement ((kind, body) : mt) : CST.empty_statement =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_implicit_type ((kind, body) : mt) : CST.implicit_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_break_statement ((kind, body) : mt) : CST.break_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_imm_tok_pat_5a6fa79 ((kind, body) : mt) : CST.imm_tok_pat_5a6fa79 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_boolean_literal ((kind, body) : mt) : CST.boolean_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `True (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `False (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_integer_literal ((kind, body) : mt) : CST.integer_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_interpolated_verbatim_string_text ((kind, body) : mt) : CST.interpolated_verbatim_string_text =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_6d9db72 (
            trans_pat_6d9db72 (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DQUOTDQUOT (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_interpolation_format_clause ((kind, body) : mt) : CST.interpolation_format_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pat_52ffbd7 (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_interpolated_string_text ((kind, body) : mt) : CST.interpolated_string_text =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LCURLLCURL (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Imm_tok_pat_2755817 (
            trans_imm_tok_pat_2755817 (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Esc_seq (
            trans_escape_sequence (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_character_literal ((kind, body) : mt) : CST.character_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Imm_tok_pat_684220d (
                  trans_imm_tok_pat_684220d (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Esc_seq (
                  trans_escape_sequence (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_extern_alias_directive ((kind, body) : mt) : CST.extern_alias_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_name_equals ((kind, body) : mt) : CST.name_equals =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Global (
                  trans_global (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_tuple_pattern ((kind, body) : mt) : CST.tuple_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Disc (
                  trans_discard (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Id (
                            trans_identifier (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Disc (
                            trans_discard (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_join_into_clause ((kind, body) : mt) : CST.join_into_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let rec trans_parenthesized_variable_designation ((kind, body) : mt) : CST.parenthesized_variable_designation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_variable_designation (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_variable_designation (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_variable_designation ((kind, body) : mt) : CST.variable_designation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Disc (
            trans_discard (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Paren_var_desi (
            trans_parenthesized_variable_designation (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_name_colon ((kind, body) : mt) : CST.name_colon =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Global (
                  trans_global (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Imm_tok_pat_5a6fa79 (
                      trans_imm_tok_pat_5a6fa79 (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_var_pattern ((kind, body) : mt) : CST.var_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_variable_designation (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_literal ((kind, body) : mt) : CST.literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Null_lit (
            trans_null_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bool_lit (
            trans_boolean_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Char_lit (
            trans_character_literal (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Real_lit (
            trans_real_literal (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Int_lit (
            trans_integer_literal (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Verb_str_lit (
            trans_verbatim_string_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let rec trans_alias_qualified_name ((kind, body) : mt) : CST.alias_qualified_name =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Global (
                  trans_global (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_simple_name (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_anonymous_method_expression ((kind, body) : mt) : CST.anonymous_method_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_parameter_list (Run.matcher_token v))
              v2
            ,
            trans_block (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_anonymous_object_creation_expression ((kind, body) : mt) : CST.anonymous_object_creation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_anonymous_object_member_declarator (Run.matcher_token v0)
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_anonymous_object_member_declarator (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_anonymous_object_member_declarator ((kind, body) : mt) : CST.anonymous_object_member_declarator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Name_equals_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_name_equals (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_argument ((kind, body) : mt) : CST.argument =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_name_colon (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Ref (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Out (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `In (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Decl_exp (
                  trans_declaration_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_argument_list ((kind, body) : mt) : CST.argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_argument (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_argument (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_creation_expression ((kind, body) : mt) : CST.array_creation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_array_type (Run.matcher_token v1),
            Run.opt
              (fun v ->
                trans_initializer_expression (Run.matcher_token v)
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_rank_specifier ((kind, body) : mt) : CST.array_rank_specifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.opt
                        (fun v -> trans_expression (Run.matcher_token v))
                        v0
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                Run.opt
                                  (fun v -> trans_expression (Run.matcher_token v))
                                  v1
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_type ((kind, body) : mt) : CST.array_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_ (Run.matcher_token v0),
            trans_array_rank_specifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_arrow_expression_clause ((kind, body) : mt) : CST.arrow_expression_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignment_expression ((kind, body) : mt) : CST.assignment_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_assignment_operator (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_attribute ((kind, body) : mt) : CST.attribute =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_name (Run.matcher_token v0),
            Run.opt
              (fun v ->
                trans_attribute_argument_list (Run.matcher_token v)
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_attribute_argument ((kind, body) : mt) : CST.attribute_argument =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Name_equals (
                      trans_name_equals (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Name_colon (
                      trans_name_colon (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_attribute_argument_list ((kind, body) : mt) : CST.attribute_argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_attribute_argument (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_attribute_argument (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_attribute_list ((kind, body) : mt) : CST.attribute_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                trans_attribute_target_specifier (Run.matcher_token v)
              )
              v1
            ,
            trans_attribute (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_attribute (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_await_expression ((kind, body) : mt) : CST.await_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_expression ((kind, body) : mt) : CST.binary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_AMPAMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_BARBAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Exp_GTGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Exp_LTLT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Exp_AMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Exp_HAT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Exp_BAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Exp_PLUS_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Exp_DASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Exp_STAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Exp_SLASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Exp_PERC_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Exp_LT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Exp_LTEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (14, v) ->
          `Exp_EQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (15, v) ->
          `Exp_BANGEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (16, v) ->
          `Exp_GTEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (17, v) ->
          `Exp_GT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (18, v) ->
          `Exp_QMARKQMARK_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (19, v) ->
          `Exp_choice_is_type (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Is (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `As (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_type_ (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block ((kind, body) : mt) : CST.block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bracketed_argument_list ((kind, body) : mt) : CST.bracketed_argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_argument (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_argument (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_case_pattern_switch_label ((kind, body) : mt) : CST.case_pattern_switch_label =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pattern (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_when_clause (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_case_switch_label ((kind, body) : mt) : CST.case_switch_label =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_cast_expression ((kind, body) : mt) : CST.cast_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_expression (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_catch_clause ((kind, body) : mt) : CST.catch_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_catch_declaration (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_catch_filter_clause (Run.matcher_token v))
              v2
            ,
            trans_block (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_catch_declaration ((kind, body) : mt) : CST.catch_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_catch_filter_clause ((kind, body) : mt) : CST.catch_filter_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_checked_expression ((kind, body) : mt) : CST.checked_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Chec_LPAR_exp_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Unch_LPAR_exp_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_checked_statement ((kind, body) : mt) : CST.checked_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Chec (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Unch (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_conditional_access_expression ((kind, body) : mt) : CST.conditional_access_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_conditional_expression ((kind, body) : mt) : CST.conditional_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constant_pattern ((kind, body) : mt) : CST.constant_pattern =
  match body with
  | Children v ->
      trans_expression (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_declaration_expression ((kind, body) : mt) : CST.declaration_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_ (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_declaration_pattern ((kind, body) : mt) : CST.declaration_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_ (Run.matcher_token v0),
            trans_variable_designation (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_deep_ellipsis ((kind, body) : mt) : CST.deep_ellipsis =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_default_expression ((kind, body) : mt) : CST.default_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1),
                      Run.trans_token (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_do_statement ((kind, body) : mt) : CST.do_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_statement (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5),
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_element_access_expression ((kind, body) : mt) : CST.element_access_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_bracketed_argument_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_element_binding_expression ((kind, body) : mt) : CST.element_binding_expression =
  match body with
  | Children v ->
      trans_bracketed_argument_list (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_equals_value_clause ((kind, body) : mt) : CST.equals_value_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Anon_meth_exp (
            trans_anonymous_method_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Anon_obj_crea_exp (
            trans_anonymous_object_creation_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Array_crea_exp (
            trans_array_creation_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Assign_exp (
            trans_assignment_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Await_exp (
            trans_await_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Base_exp (
            trans_base_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Bin_exp (
            trans_binary_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Cast_exp (
            trans_cast_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Chec_exp (
            trans_checked_expression (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Cond_access_exp (
            trans_conditional_access_expression (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Cond_exp (
            trans_conditional_expression (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Defa_exp (
            trans_default_expression (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Elem_access_exp (
            trans_element_access_expression (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Elem_bind_exp (
            trans_element_binding_expression (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Impl_array_crea_exp (
            trans_implicit_array_creation_expression (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Impl_stack_alloc_array_crea_exp (
            trans_implicit_stack_alloc_array_creation_expression (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Init_exp (
            trans_initializer_expression (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Inte_str_exp (
            trans_interpolated_string_expression (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Invo_exp (
            trans_invocation_expression (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Is_pat_exp (
            trans_is_pattern_expression (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `Lambda_exp (
            trans_lambda_expression (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `Make_ref_exp (
            trans_make_ref_expression (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `Member_access_exp (
            trans_member_access_expression (Run.matcher_token v)
          )
      | Alt (23, v) ->
          `Member_bind_exp (
            trans_member_binding_expression (Run.matcher_token v)
          )
      | Alt (24, v) ->
          `Obj_crea_exp (
            trans_object_creation_expression (Run.matcher_token v)
          )
      | Alt (25, v) ->
          `Paren_exp (
            trans_parenthesized_expression (Run.matcher_token v)
          )
      | Alt (26, v) ->
          `Post_un_exp (
            trans_postfix_unary_expression (Run.matcher_token v)
          )
      | Alt (27, v) ->
          `Prefix_un_exp (
            trans_prefix_unary_expression (Run.matcher_token v)
          )
      | Alt (28, v) ->
          `Query_exp (
            trans_query_expression (Run.matcher_token v)
          )
      | Alt (29, v) ->
          `Range_exp (
            trans_range_expression (Run.matcher_token v)
          )
      | Alt (30, v) ->
          `Ref_exp (
            trans_ref_expression (Run.matcher_token v)
          )
      | Alt (31, v) ->
          `Ref_type_exp (
            trans_ref_type_expression (Run.matcher_token v)
          )
      | Alt (32, v) ->
          `Ref_value_exp (
            trans_ref_value_expression (Run.matcher_token v)
          )
      | Alt (33, v) ->
          `Size_of_exp (
            trans_size_of_expression (Run.matcher_token v)
          )
      | Alt (34, v) ->
          `Stack_alloc_array_crea_exp (
            trans_stack_alloc_array_creation_expression (Run.matcher_token v)
          )
      | Alt (35, v) ->
          `Switch_exp (
            trans_switch_expression (Run.matcher_token v)
          )
      | Alt (36, v) ->
          `This_exp (
            trans_this_expression (Run.matcher_token v)
          )
      | Alt (37, v) ->
          `Throw_exp (
            trans_throw_expression (Run.matcher_token v)
          )
      | Alt (38, v) ->
          `Tuple_exp (
            trans_tuple_expression (Run.matcher_token v)
          )
      | Alt (39, v) ->
          `Type_of_exp (
            trans_type_of_expression (Run.matcher_token v)
          )
      | Alt (40, v) ->
          `Simple_name (
            trans_simple_name (Run.matcher_token v)
          )
      | Alt (41, v) ->
          `Rese_id (
            trans_reserved_identifier (Run.matcher_token v)
          )
      | Alt (42, v) ->
          `Lit (
            trans_literal (Run.matcher_token v)
          )
      | Alt (43, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | Alt (44, v) ->
          `Deep_ellips (
            trans_deep_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression_statement ((kind, body) : mt) : CST.expression_statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_SEMI (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips_SEMI (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_ellipsis (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_finally_clause ((kind, body) : mt) : CST.finally_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_fixed_statement ((kind, body) : mt) : CST.fixed_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_variable_declaration (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_statement (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_each_statement ((kind, body) : mt) : CST.for_each_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Type_id (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_type_ (Run.matcher_token v0),
                        trans_identifier (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v4),
            trans_expression (Run.matcher_token v5),
            Run.trans_token (Run.matcher_token v6),
            trans_statement (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_statement ((kind, body) : mt) : CST.for_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Var_decl (
                      trans_variable_declaration (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Exp_rep_COMMA_exp (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_expression (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_expression (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expression (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v6
            ,
            Run.trans_token (Run.matcher_token v7),
            trans_statement (Run.matcher_token v8)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_formal_parameter_list ((kind, body) : mt) : CST.formal_parameter_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Param (
                  trans_parameter (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Param_array (
                  trans_parameter_array (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Param (
                            trans_parameter (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Param_array (
                            trans_parameter_array (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_from_clause ((kind, body) : mt) : CST.from_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_ (Run.matcher_token v))
              v1
            ,
            trans_identifier (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_body ((kind, body) : mt) : CST.function_body =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Blk (
            trans_block (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Arrow_exp_clause_SEMI (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_arrow_expression_clause (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `SEMI (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_generic_name ((kind, body) : mt) : CST.generic_name =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            trans_type_argument_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_goto_statement ((kind, body) : mt) : CST.goto_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Case_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Defa (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_group_clause ((kind, body) : mt) : CST.group_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_expression (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_statement ((kind, body) : mt) : CST.if_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_statement (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_statement (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_implicit_array_creation_expression ((kind, body) : mt) : CST.implicit_array_creation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_initializer_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_implicit_stack_alloc_array_creation_expression ((kind, body) : mt) : CST.implicit_stack_alloc_array_creation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_initializer_expression (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_initializer_expression ((kind, body) : mt) : CST.initializer_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expression (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interpolated_string_content ((kind, body) : mt) : CST.interpolated_string_content =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Inte_str_text (
            trans_interpolated_string_text (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Interp (
            trans_interpolation (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interpolated_string_expression ((kind, body) : mt) : CST.interpolated_string_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `DOLLARDQUOT_rep_inte_str_content_DQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      trans_interpolated_string_content (Run.matcher_token v)
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `DOLLARATDQUOT_rep_inte_verb_str_content_DQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      trans_interpolated_verbatim_string_content (Run.matcher_token v)
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interpolated_verbatim_string_content ((kind, body) : mt) : CST.interpolated_verbatim_string_content =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Inte_verb_str_text (
            trans_interpolated_verbatim_string_text (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Interp (
            trans_interpolation (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interpolation ((kind, body) : mt) : CST.interpolation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.opt
              (fun v ->
                trans_interpolation_alignment_clause (Run.matcher_token v)
              )
              v2
            ,
            Run.opt
              (fun v ->
                trans_interpolation_format_clause (Run.matcher_token v)
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interpolation_alignment_clause ((kind, body) : mt) : CST.interpolation_alignment_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_invocation_expression ((kind, body) : mt) : CST.invocation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_argument_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_is_pattern_expression ((kind, body) : mt) : CST.is_pattern_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_pattern (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_join_clause ((kind, body) : mt) : CST.join_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8; v9] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_ (Run.matcher_token v))
              v1
            ,
            trans_identifier (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5),
            trans_expression (Run.matcher_token v6),
            Run.trans_token (Run.matcher_token v7),
            trans_expression (Run.matcher_token v8),
            Run.opt
              (fun v -> trans_join_into_clause (Run.matcher_token v))
              v9
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_labeled_statement ((kind, body) : mt) : CST.labeled_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_statement (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lambda_expression ((kind, body) : mt) : CST.lambda_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Param_list (
                  trans_parameter_list (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Blk (
                  trans_block (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_let_clause ((kind, body) : mt) : CST.let_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_expression (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_local_declaration_statement ((kind, body) : mt) : CST.local_declaration_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v2
            ,
            trans_variable_declaration (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_local_function_statement ((kind, body) : mt) : CST.local_function_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Type (
                  trans_type_ (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Void_kw (
                  trans_void_keyword (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_parameter_list (Run.matcher_token v))
              v3
            ,
            trans_parameter_list (Run.matcher_token v4),
            Run.repeat
              (fun v ->
                trans_type_parameter_constraints_clause (Run.matcher_token v)
              )
              v5
            ,
            trans_function_body (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lock_statement ((kind, body) : mt) : CST.lock_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_statement (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_make_ref_expression ((kind, body) : mt) : CST.make_ref_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_member_access_expression ((kind, body) : mt) : CST.member_access_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type (
                  trans_type_ (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Name (
                  trans_name (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `DOT (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `DASHGT (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_simple_name (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_member_binding_expression ((kind, body) : mt) : CST.member_binding_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_simple_name (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_name ((kind, body) : mt) : CST.name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Alias_qual_name (
            trans_alias_qualified_name (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Qual_name (
            trans_qualified_name (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Simple_name (
            trans_simple_name (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_nullable_type ((kind, body) : mt) : CST.nullable_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_QMARK (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_type_ (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_creation_expression ((kind, body) : mt) : CST.object_creation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_argument_list (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v ->
                trans_initializer_expression (Run.matcher_token v)
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_order_by_clause ((kind, body) : mt) : CST.order_by_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_ordering (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_ordering (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ordering ((kind, body) : mt) : CST.ordering =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Asce (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Desc (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameter ((kind, body) : mt) : CST.parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_parameter_modifier (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_type_ (Run.matcher_token v))
              v2
            ,
            trans_identifier (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_equals_value_clause (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameter_array ((kind, body) : mt) : CST.parameter_array =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_array_type (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameter_list ((kind, body) : mt) : CST.parameter_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_formal_parameter_list (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_expression ((kind, body) : mt) : CST.parenthesized_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pattern ((kind, body) : mt) : CST.pattern =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Cst_pat (
            trans_constant_pattern (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Decl_pat (
            trans_declaration_pattern (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Disc (
            trans_discard (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Var_pat (
            trans_var_pattern (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pointer_type ((kind, body) : mt) : CST.pointer_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_ (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_postfix_unary_expression ((kind, body) : mt) : CST.postfix_unary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_PLUSPLUS (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_DASHDASH (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Exp_BANG (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_prefix_unary_expression ((kind, body) : mt) : CST.prefix_unary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `BANG_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `AMP_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `STAR_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `PLUS_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `PLUSPLUS_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `DASH_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `DASHDASH_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `HAT_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `TILDE_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_qualified_name ((kind, body) : mt) : CST.qualified_name =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_name (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_simple_name (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_query_body ((kind, body) : mt) : CST.query_body =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Rectype (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.repeat
                    (fun v -> trans_query_clause (Run.matcher_token v))
                    v0
                  ,
                  trans_select_or_group_clause (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_query_continuation (Run.matcher_token v))
                    v2
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_query_clause ((kind, body) : mt) : CST.query_clause =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `From_clause (
            trans_from_clause (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Join_clause (
            trans_join_clause (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Let_clause (
            trans_let_clause (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Order_by_clause (
            trans_order_by_clause (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Where_clause (
            trans_where_clause (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_query_continuation ((kind, body) : mt) : CST.query_continuation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Rectype (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_identifier (Run.matcher_token v1),
                  trans_query_body (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_query_expression ((kind, body) : mt) : CST.query_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_from_clause (Run.matcher_token v0),
            trans_query_body (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_range_expression ((kind, body) : mt) : CST.range_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ref_expression ((kind, body) : mt) : CST.ref_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ref_type_expression ((kind, body) : mt) : CST.ref_type_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ref_value_expression ((kind, body) : mt) : CST.ref_value_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_type_ (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_return_statement ((kind, body) : mt) : CST.return_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_select_clause ((kind, body) : mt) : CST.select_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_select_or_group_clause ((kind, body) : mt) : CST.select_or_group_clause =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Group_clause (
            trans_group_clause (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Select_clause (
            trans_select_clause (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_simple_name ((kind, body) : mt) : CST.simple_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Gene_name (
            trans_generic_name (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Choice_global (
            (match v with
            | Alt (0, v) ->
                `Global (
                  trans_global (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_size_of_expression ((kind, body) : mt) : CST.size_of_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_stack_alloc_array_creation_expression ((kind, body) : mt) : CST.stack_alloc_array_creation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_array_type (Run.matcher_token v1),
            Run.opt
              (fun v ->
                trans_initializer_expression (Run.matcher_token v)
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_statement ((kind, body) : mt) : CST.statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Blk (
            trans_block (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Brk_stmt (
            trans_break_statement (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Chec_stmt (
            trans_checked_statement (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Cont_stmt (
            trans_continue_statement (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Do_stmt (
            trans_do_statement (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Empty_stmt (
            trans_empty_statement (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Exp_stmt (
            trans_expression_statement (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Fixed_stmt (
            trans_fixed_statement (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `For_each_stmt (
            trans_for_each_statement (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `For_stmt (
            trans_for_statement (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Goto_stmt (
            trans_goto_statement (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `If_stmt (
            trans_if_statement (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Labe_stmt (
            trans_labeled_statement (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Local_decl_stmt (
            trans_local_declaration_statement (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Local_func_stmt (
            trans_local_function_statement (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Lock_stmt (
            trans_lock_statement (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Ret_stmt (
            trans_return_statement (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Switch_stmt (
            trans_switch_statement (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Throw_stmt (
            trans_throw_statement (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Try_stmt (
            trans_try_statement (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `Unsafe_stmt (
            trans_unsafe_statement (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `Using_stmt (
            trans_using_statement (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `While_stmt (
            trans_while_statement (Run.matcher_token v)
          )
      | Alt (23, v) ->
          `Yield_stmt (
            trans_yield_statement (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_body ((kind, body) : mt) : CST.switch_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_switch_section (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_expression ((kind, body) : mt) : CST.switch_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_switch_expression_arm (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_switch_expression_arm (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_expression_arm ((kind, body) : mt) : CST.switch_expression_arm =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_pattern (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_when_clause (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_expression (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_section ((kind, body) : mt) : CST.switch_section =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Case_switch_label (
                      trans_case_switch_label (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Case_pat_switch_label (
                      trans_case_pattern_switch_label (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Defa_switch_label (
                      trans_default_switch_label (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            Run.repeat1
              (fun v -> trans_statement (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_statement ((kind, body) : mt) : CST.switch_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_switch_body (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_throw_expression ((kind, body) : mt) : CST.throw_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_throw_statement ((kind, body) : mt) : CST.throw_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_try_statement ((kind, body) : mt) : CST.try_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_catch_clause (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_finally_clause (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple_element ((kind, body) : mt) : CST.tuple_element =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_ (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple_expression ((kind, body) : mt) : CST.tuple_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_argument (Run.matcher_token v1),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_argument (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple_type ((kind, body) : mt) : CST.tuple_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_tuple_element (Run.matcher_token v1),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_tuple_element (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Impl_type (
            trans_implicit_type (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Array_type (
            trans_array_type (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Name (
            trans_name (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Null_type (
            trans_nullable_type (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Poin_type (
            trans_pointer_type (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Pred_type (
            trans_predefined_type (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Tuple_type (
            trans_tuple_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_argument_list ((kind, body) : mt) : CST.type_argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Rep_COMMA (
                  Run.repeat
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v
                )
            | Alt (1, v) ->
                `Type_rep_COMMA_type (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_type_ (Run.matcher_token v0),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_type_ (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_constraint ((kind, body) : mt) : CST.type_constraint =
  match body with
  | Children v ->
      trans_type_ (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_type_of_expression ((kind, body) : mt) : CST.type_of_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameter ((kind, body) : mt) : CST.type_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `In (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Out (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameter_constraint ((kind, body) : mt) : CST.type_parameter_constraint =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Class (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Struct (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Unma (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Cons_cons (
            trans_constructor_constraint (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Type_cons (
            trans_type_constraint (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameter_constraints_clause ((kind, body) : mt) : CST.type_parameter_constraints_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Global (
                  trans_global (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_type_parameter_constraint (Run.matcher_token v3),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_parameter_constraint (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameter_list ((kind, body) : mt) : CST.type_parameter_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unsafe_statement ((kind, body) : mt) : CST.unsafe_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_using_statement ((kind, body) : mt) : CST.using_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Var_decl (
                  trans_variable_declaration (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v4),
            trans_statement (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_variable_declaration ((kind, body) : mt) : CST.variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_type_ (Run.matcher_token v0),
            trans_variable_declarator (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_variable_declarator (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_variable_declarator ((kind, body) : mt) : CST.variable_declarator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Tuple_pat (
                  trans_tuple_pattern (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v ->
                trans_bracketed_argument_list (Run.matcher_token v)
              )
              v1
            ,
            Run.opt
              (fun v -> trans_equals_value_clause (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_when_clause ((kind, body) : mt) : CST.when_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_where_clause ((kind, body) : mt) : CST.where_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_statement ((kind, body) : mt) : CST.while_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_statement (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_yield_statement ((kind, body) : mt) : CST.yield_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Ret_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Brk (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_conversion_operator_declaration ((kind, body) : mt) : CST.conversion_operator_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Impl (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Expl (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_type_ (Run.matcher_token v4),
            trans_parameter_list (Run.matcher_token v5),
            trans_function_body (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_event_field_declaration ((kind, body) : mt) : CST.event_field_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_variable_declaration (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_base_list ((kind, body) : mt) : CST.base_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_explicit_interface_specifier ((kind, body) : mt) : CST.explicit_interface_specifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_name (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_bracketed_parameter_list ((kind, body) : mt) : CST.bracketed_parameter_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_operator_declaration ((kind, body) : mt) : CST.operator_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            trans_type_ (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_overloadable_operator (Run.matcher_token v4),
            trans_parameter_list (Run.matcher_token v5),
            trans_function_body (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_using_directive ((kind, body) : mt) : CST.using_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Static (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Name_equals (
                      trans_name_equals (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_name (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_constructor_initializer ((kind, body) : mt) : CST.constructor_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Base (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `This (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_argument_list (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_semgrep_expression ((kind, body) : mt) : CST.semgrep_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_destructor_declaration ((kind, body) : mt) : CST.destructor_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            trans_parameter_list (Run.matcher_token v4),
            trans_function_body (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_field_declaration ((kind, body) : mt) : CST.field_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            trans_variable_declaration (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_enum_member_declaration ((kind, body) : mt) : CST.enum_member_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_accessor_declaration ((kind, body) : mt) : CST.accessor_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Get (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Set (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Add (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Remove (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_function_body (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_global_attribute_list ((kind, body) : mt) : CST.global_attribute_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Asse (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Module (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_attribute (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_attribute (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_delegate_declaration ((kind, body) : mt) : CST.delegate_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Type (
                  trans_type_ (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Void_kw (
                  trans_void_keyword (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_identifier (Run.matcher_token v4),
            Run.opt
              (fun v -> trans_type_parameter_list (Run.matcher_token v))
              v5
            ,
            trans_parameter_list (Run.matcher_token v6),
            Run.repeat
              (fun v ->
                trans_type_parameter_constraints_clause (Run.matcher_token v)
              )
              v7
            ,
            Run.trans_token (Run.matcher_token v8)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_method_declaration ((kind, body) : mt) : CST.method_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Type (
                  trans_type_ (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Void_kw (
                  trans_void_keyword (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v ->
                trans_explicit_interface_specifier (Run.matcher_token v)
              )
              v3
            ,
            trans_identifier (Run.matcher_token v4),
            Run.opt
              (fun v -> trans_type_parameter_list (Run.matcher_token v))
              v5
            ,
            trans_parameter_list (Run.matcher_token v6),
            Run.repeat
              (fun v ->
                trans_type_parameter_constraints_clause (Run.matcher_token v)
              )
              v7
            ,
            trans_function_body (Run.matcher_token v8)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_constructor_declaration ((kind, body) : mt) : CST.constructor_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            trans_identifier (Run.matcher_token v2),
            trans_parameter_list (Run.matcher_token v3),
            Run.opt
              (fun v ->
                trans_constructor_initializer (Run.matcher_token v)
              )
              v4
            ,
            trans_function_body (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_enum_member_declaration_list ((kind, body) : mt) : CST.enum_member_declaration_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_enum_member_declaration (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_enum_member_declaration (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_accessor_list ((kind, body) : mt) : CST.accessor_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_accessor_declaration (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_enum_declaration ((kind, body) : mt) : CST.enum_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_base_list (Run.matcher_token v))
              v4
            ,
            trans_enum_member_declaration_list (Run.matcher_token v5),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v6
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_property_declaration ((kind, body) : mt) : CST.property_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            trans_type_ (Run.matcher_token v2),
            Run.opt
              (fun v ->
                trans_explicit_interface_specifier (Run.matcher_token v)
              )
              v3
            ,
            trans_identifier (Run.matcher_token v4),
            (match v5 with
            | Alt (0, v) ->
                `Acce_list_opt_EQ_exp_SEMI (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_accessor_list (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_expression (Run.matcher_token v1),
                                  Run.trans_token (Run.matcher_token v2)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Arrow_exp_clause_SEMI (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_arrow_expression_clause (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_indexer_declaration ((kind, body) : mt) : CST.indexer_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            trans_type_ (Run.matcher_token v2),
            Run.opt
              (fun v ->
                trans_explicit_interface_specifier (Run.matcher_token v)
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4),
            trans_bracketed_parameter_list (Run.matcher_token v5),
            (match v6 with
            | Alt (0, v) ->
                `Acce_list (
                  trans_accessor_list (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Arrow_exp_clause_SEMI (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_arrow_expression_clause (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_event_declaration ((kind, body) : mt) : CST.event_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_type_ (Run.matcher_token v3),
            Run.opt
              (fun v ->
                trans_explicit_interface_specifier (Run.matcher_token v)
              )
              v4
            ,
            trans_identifier (Run.matcher_token v5),
            (match v6 with
            | Alt (0, v) ->
                `Acce_list (
                  trans_accessor_list (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `SEMI (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_class_declaration ((kind, body) : mt) : CST.class_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_type_parameter_list (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_base_list (Run.matcher_token v))
              v5
            ,
            Run.repeat
              (fun v ->
                trans_type_parameter_constraints_clause (Run.matcher_token v)
              )
              v6
            ,
            trans_declaration_list (Run.matcher_token v7),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v8
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_declaration ((kind, body) : mt) : CST.declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Global_attr_list (
            trans_global_attribute_list (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Class_decl (
            trans_class_declaration (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Cons_decl (
            trans_constructor_declaration (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Conv_op_decl (
            trans_conversion_operator_declaration (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Dele_decl (
            trans_delegate_declaration (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Dest_decl (
            trans_destructor_declaration (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Enum_decl (
            trans_enum_declaration (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Event_decl (
            trans_event_declaration (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Extern_alias_dire (
            trans_extern_alias_directive (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Event_field_decl (
            trans_event_field_declaration (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Field_decl (
            trans_field_declaration (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Inde_decl (
            trans_indexer_declaration (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Inte_decl (
            trans_interface_declaration (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Meth_decl (
            trans_method_declaration (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Name_decl (
            trans_namespace_declaration (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Op_decl (
            trans_operator_declaration (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Prop_decl (
            trans_property_declaration (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Struct_decl (
            trans_struct_declaration (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Using_dire (
            trans_using_directive (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_declaration_list ((kind, body) : mt) : CST.declaration_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_declaration (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interface_declaration ((kind, body) : mt) : CST.interface_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_type_parameter_list (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_base_list (Run.matcher_token v))
              v5
            ,
            Run.repeat
              (fun v ->
                trans_type_parameter_constraints_clause (Run.matcher_token v)
              )
              v6
            ,
            trans_declaration_list (Run.matcher_token v7),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v8
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_namespace_declaration ((kind, body) : mt) : CST.namespace_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_name (Run.matcher_token v1),
            trans_declaration_list (Run.matcher_token v2),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_struct_declaration ((kind, body) : mt) : CST.struct_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
          (
            Run.repeat
              (fun v -> trans_attribute_list (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_type_parameter_list (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_base_list (Run.matcher_token v))
              v5
            ,
            Run.repeat
              (fun v ->
                trans_type_parameter_constraints_clause (Run.matcher_token v)
              )
              v6
            ,
            trans_declaration_list (Run.matcher_token v7),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v8
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_compilation_unit ((kind, body) : mt) : CST.compilation_unit =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Rep_decl (
            Run.repeat
              (fun v -> trans_declaration (Run.matcher_token v))
              v
          )
      | Alt (1, v) ->
          `Semg_exp (
            trans_semgrep_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_compilation_unit matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

