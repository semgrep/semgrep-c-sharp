(* Generated by ocaml-tree-sitter. *)
(*
   c_sharp grammar

   entrypoint: compilation_unit
*)

open! Sexplib.Conv
open Tree_sitter_run

type overloadable_operator = [
    `BANG of Token.t (* "!" *)
  | `TILDE of Token.t (* "~" *)
  | `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
  | `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
  | `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
  | `STAR of Token.t (* "*" *)
  | `SLASH of Token.t (* "/" *)
  | `PERC of Token.t (* "%" *)
  | `HAT of Token.t (* "^" *)
  | `BAR of Token.t (* "|" *)
  | `AMP of Token.t (* "&" *)
  | `LTLT of Token.t (* "<<" *)
  | `GTGT of Token.t (* ">>" *)
  | `GTGTGT of Token.t (* ">>>" *)
  | `EQEQ of Token.t (* "==" *)
  | `BANGEQ of Token.t (* "!=" *)
  | `GT of Token.t (* ">" *)
  | `LT of Token.t (* "<" *)
  | `GTEQ of Token.t (* ">=" *)
  | `LTEQ of Token.t (* "<=" *)
]

type string_literal_fragment = Token.t (* pattern "[^\"\\\\\\n]+" *)

type anon_choice_async_25087f5 = [
    `Async of Token.t (* "async" *)
  | `Static of Token.t (* "static" *)
  | `Async_static of (Token.t (* "async" *) * Token.t (* "static" *))
  | `Static_async of (Token.t (* "static" *) * Token.t (* "async" *))
]

type semgrep_variadic_metavariable =
  Token.t (* pattern \$\.\.\.[A-Z_][A-Z_0-9]* *)

type semgrep_metavariable = Token.t

type preproc_directive_start = Token.t (* pattern #[ \t]* *)

type identifier_token = Token.t

type opt_semi = Token.t

type anon_choice_ref_eec35e8 = [
    `Ref of Token.t (* "ref" *)
  | `Out of Token.t (* "out" *)
  | `In of Token.t (* "in" *)
]

type raw_string_literal = Token.t

type nullable_directive = (
    Token.t (* "nullable" *)
  * [
        `Disa of Token.t (* "disable" *)
      | `Enable of Token.t (* "enable" *)
      | `Rest of Token.t (* "restore" *)
    ]
  * [
        `Annots of Token.t (* "annotations" *)
      | `Warnis of Token.t (* "warnings" *)
    ]
      option
)

type anon_choice_DOT_2ad1dab = [
    `DOT of Token.t (* "." *)
  | `DASHGT of Token.t (* "->" *)
]

type contextual_keywords = [
    `Alias of Token.t (* "alias" *)
  | `Asce of Token.t (* "ascending" *)
  | `By of Token.t (* "by" *)
  | `Desc of Token.t (* "descending" *)
  | `Equals of Token.t (* "equals" *)
  | `File of Token.t (* "file" *)
  | `From of Token.t (* "from" *)
  | `Global of Token.t (* "global" *)
  | `Group of Token.t (* "group" *)
  | `Into of Token.t (* "into" *)
  | `Join of Token.t (* "join" *)
  | `Let of Token.t (* "let" *)
  | `Notn of Token.t (* "notnull" *)
  | `On of Token.t (* "on" *)
  | `Orde of Token.t (* "orderby" *)
  | `Scoped of Token.t (* "scoped" *)
  | `Select of Token.t (* "select" *)
  | `Unma of Token.t (* "unmanaged" *)
  | `Var of Token.t (* "var" *)
  | `When of Token.t (* "when" *)
  | `Where of Token.t (* "where" *)
  | `Yield of Token.t (* "yield" *)
]

type assignment_operator = [
    `EQ of Token.t (* "=" *)
  | `PLUSEQ of Token.t (* "+=" *)
  | `DASHEQ of Token.t (* "-=" *)
  | `STAREQ of Token.t (* "*=" *)
  | `SLASHEQ of Token.t (* "/=" *)
  | `PERCEQ of Token.t (* "%=" *)
  | `AMPEQ of Token.t (* "&=" *)
  | `HATEQ of Token.t (* "^=" *)
  | `BAREQ of Token.t (* "|=" *)
  | `LTLTEQ of Token.t (* "<<=" *)
  | `GTGTEQ of Token.t (* ">>=" *)
  | `GTGTGTEQ of Token.t (* ">>>=" *)
  | `QMARKQMARKEQ of Token.t (* "??=" *)
]

type boolean_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]

type interpolated_string_text_fragment =
  Token.t (* pattern "[^{\"\\\\\\n]+" *)

type string_literal_encoding = Token.t (* pattern (u|U)8 *)

type character_literal_unescaped = Token.t (* pattern "[^'\\\\]" *)

type preproc_integer_literal = Token.t (* pattern [0-9]+ *)

type integer_literal = Token.t

type default_switch_label = (Token.t (* "default" *) * Token.t (* ":" *))

type pat_52ffbd7 = Token.t (* pattern "[^}\"]+" *)

type interpolated_verbatim_string_text_fragment =
  Token.t (* pattern "[^{\"]+" *)

type preproc_message = Token.t (* pattern [^\n\r]+ *)

type real_literal = Token.t

type modifier = [
    `Abst of Token.t (* "abstract" *)
  | `Async of Token.t (* "async" *)
  | `Const of Token.t (* "const" *)
  | `Extern of Token.t (* "extern" *)
  | `File of Token.t (* "file" *)
  | `Fixed of Token.t (* "fixed" *)
  | `Inte of Token.t (* "internal" *)
  | `New of Token.t (* "new" *)
  | `Over of Token.t (* "override" *)
  | `Part of Token.t (* "partial" *)
  | `Priv of Token.t (* "private" *)
  | `Prot of Token.t (* "protected" *)
  | `Public of Token.t (* "public" *)
  | `Read of Token.t (* "readonly" *)
  | `Requ of Token.t (* "required" *)
  | `Sealed of Token.t (* "sealed" *)
  | `Static of Token.t (* "static" *)
  | `Unsafe of Token.t (* "unsafe" *)
  | `Virt of Token.t (* "virtual" *)
  | `Vola of Token.t (* "volatile" *)
]

type verbatim_string_literal = Token.t

type preproc_string_literal = Token.t (* pattern "\"[^\"]*\"" *)

type attribute_target_specifier = (
    [
        `Field of Token.t (* "field" *)
      | `Event of Token.t (* "event" *)
      | `Meth of Token.t (* "method" *)
      | `Param of Token.t (* "param" *)
      | `Prop of Token.t (* "property" *)
      | `Ret of Token.t (* "return" *)
      | `Type of Token.t (* "type" *)
    ]
  * Token.t (* ":" *)
)

type escape_sequence = Token.t

type pat_00238b3 = Token.t (* pattern [^\n\r]* *)

type preproc_directive_end = Token.t

type predefined_type = Token.t

type identifier = [
    `Choice_id_tok of [
        `Id_tok of identifier_token (*tok*)
      | `Cont_keywos of contextual_keywords
    ]
  | `Semg_meta of semgrep_metavariable (*tok*)
]

type interpolation_format_clause = (Token.t (* ":" *) * pat_52ffbd7)

type interpolated_raw_string_text = [
    `Inte_verb_str_text_frag of
      interpolated_verbatim_string_text_fragment (*tok*)
  | `DQUOT of Token.t (* "\"" *)
  | `DQUOTDQUOT of Token.t (* "\"\"" *)
]

type interpolated_verbatim_string_text = [
    `LCURLLCURL of Token.t (* "{{" *)
  | `Inte_verb_str_text_frag of
      interpolated_verbatim_string_text_fragment (*tok*)
  | `DQUOTDQUOT of Token.t (* "\"\"" *)
]

type region_directive = (
    Token.t (* "region" *)
  * preproc_message (*tok*) option
)

type endregion_directive = (
    Token.t (* "endregion" *)
  * preproc_message (*tok*) option
)

type error_directive = (Token.t (* "error" *) * preproc_message (*tok*))

type warning_directive = (Token.t (* "warning" *) * preproc_message (*tok*))

type load_directive = (Token.t (* "load" *) * preproc_string_literal (*tok*))

type line_directive = (
    Token.t (* "line" *)
  * [
        `Defa of Token.t (* "default" *)
      | `Hidden of Token.t (* "hidden" *)
      | `Prep_int_lit_opt_prep_str_lit of (
            preproc_integer_literal (*tok*)
          * preproc_string_literal (*tok*) option
        )
      | `LPAR_prep_int_lit_COMMA_prep_int_lit_RPAR_DASH_LPAR_prep_int_lit_COMMA_prep_int_lit_RPAR_opt_prep_int_lit_prep_str_lit of (
            Token.t (* "(" *)
          * preproc_integer_literal (*tok*)
          * Token.t (* "," *)
          * preproc_integer_literal (*tok*)
          * Token.t (* ")" *)
          * Token.t (* "-" *)
          * Token.t (* "(" *)
          * preproc_integer_literal (*tok*)
          * Token.t (* "," *)
          * preproc_integer_literal (*tok*)
          * Token.t (* ")" *)
          * preproc_integer_literal (*tok*) option
          * preproc_string_literal (*tok*)
        )
    ]
)

type reference_directive = (
    Token.t (* "r" *) * preproc_string_literal (*tok*)
)

type interpolated_string_text = [
    `LCURLLCURL of Token.t (* "{{" *)
  | `Inte_str_text_frag of interpolated_string_text_fragment (*tok*)
  | `Esc_seq of escape_sequence (*tok*)
]

type shebang_directive = (Token.t (* "!" *) * pat_00238b3)

type function_pointer_unmanaged_calling_convention = [
    `Cdecl of Token.t (* "Cdecl" *)
  | `Stdc of Token.t (* "Stdcall" *)
  | `This of Token.t (* "Thiscall" *)
  | `Fast of Token.t (* "Fastcall" *)
  | `Id of identifier
]

type undef_directive = (Token.t (* "undef" *) * identifier)

type variable_designation = [
    `Disc of Token.t (* "_" *)
  | `Paren_var_desi of (
        Token.t (* "(" *)
      * (
            variable_designation
          * (Token.t (* "," *) * variable_designation)
              list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
    )
  | `Id of identifier
]

type join_into_clause = (Token.t (* "into" *) * identifier)

type identifier_or_global = [
    `Global of Token.t (* "global" *)
  | `Id of identifier
]

type anon_choice_id_c036834 = [
    `Id of identifier
  | `Disc of Token.t (* "_" *)
  | `Tuple_pat of tuple_pattern
]

and tuple_pattern = (
    Token.t (* "(" *)
  * anon_choice_id_c036834
  * (Token.t (* "," *) * anon_choice_id_c036834) list (* zero or more *)
  * Token.t (* ")" *)
)

type preproc_binary_expression = [
    `Prep_exp_BARBAR_prep_exp of (
        preproc_expression * Token.t (* "||" *) * preproc_expression
    )
  | `Prep_exp_AMPAMP_prep_exp of (
        preproc_expression * Token.t (* "&&" *) * preproc_expression
    )
  | `Prep_exp_EQEQ_prep_exp of (
        preproc_expression * Token.t (* "==" *) * preproc_expression
    )
  | `Prep_exp_BANGEQ_prep_exp of (
        preproc_expression * Token.t (* "!=" *) * preproc_expression
    )
]

and preproc_expression = [
    `Id of identifier
  | `Bool_lit of boolean_literal
  | `Prep_int_lit of preproc_integer_literal (*tok*)
  | `Prep_str_lit of preproc_string_literal (*tok*)
  | `Prep_un_exp of (Token.t (* "!" *) * preproc_expression)
  | `Prep_bin_exp of preproc_binary_expression
  | `Prep_paren_exp of (
        Token.t (* "(" *) * preproc_expression * Token.t (* ")" *)
    )
]

type define_directive = (Token.t (* "define" *) * identifier)

type extern_alias_directive = (
    Token.t (* "extern" *) * Token.t (* "alias" *) * identifier
  * Token.t (* ";" *)
)

type anon_choice_id_c290f8e = [
    `Id of identifier
  | `Prep_int_lit of preproc_integer_literal (*tok*)
]

type literal = [
    `Null_lit of Token.t (* "null" *)
  | `Bool_lit of boolean_literal
  | `Char_lit of (
        Token.t (* "'" *)
      * [
            `Char_lit_unes of character_literal_unescaped (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
      * Token.t (* "'" *)
    )
  | `Real_lit of real_literal (*tok*)
  | `Int_lit of integer_literal (*tok*)
  | `Str_lit of (
        Token.t (* "\"" *)
      * [
            `Str_lit_frag of string_literal_fragment (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
      * string_literal_encoding (*tok*) option
    )
  | `Verb_str_lit of verbatim_string_literal (*tok*)
  | `Raw_str_lit of raw_string_literal (*tok*)
]

type function_pointer_unmanaged_calling_convention_list = (
    Token.t (* "[" *)
  * function_pointer_unmanaged_calling_convention
  * (Token.t (* "," *) * function_pointer_unmanaged_calling_convention)
      list (* zero or more *)
  * Token.t (* "]" *)
)

type name_equals = (identifier_or_global * Token.t (* "=" *))

type name_colon = (identifier_or_global * Token.t (* ":" *))

type anon_choice_id_bf14316 = [
    `Id of identifier
  | `Tuple_pat of tuple_pattern
]

type if_directive = (Token.t (* "if" *) * preproc_expression)

type elif_directive = (Token.t (* "elif" *) * preproc_expression)

type pragma_directive = (
    Token.t (* "pragma" *)
  * [
        `Warn_choice_disa_opt_choice_id_rep_COMMA_choice_id of (
            Token.t (* "warning" *)
          * [
                `Disa of Token.t (* "disable" *)
              | `Rest of Token.t (* "restore" *)
            ]
          * (
                anon_choice_id_c290f8e
              * (Token.t (* "," *) * anon_choice_id_c290f8e)
                  list (* zero or more *)
            )
              option
        )
      | `Chec_prep_str_lit_prep_str_lit_prep_str_lit of (
            Token.t (* "checksum" *) * preproc_string_literal (*tok*)
          * preproc_string_literal (*tok*) * preproc_string_literal (*tok*)
        )
    ]
)

type function_pointer_calling_convention = [
    `Mana of Token.t (* "managed" *)
  | `Unma_opt_func_poin_unma_call_conv_list of (
        Token.t (* "unmanaged" *)
      * function_pointer_unmanaged_calling_convention_list option
    )
]

type anon_choice_exp_3bb8381 = [
    `Exp of expression
  | `Pred_type of predefined_type (*tok*)
  | `Name of type_name
]

and anon_choice_param_ce11a32 = [
    `Param of parameter
  | `Param_array of (
        attribute_list list (* zero or more *)
      * Token.t (* "params" *)
      * [ `Array_type of array_type | `Null_type of nullable_type ]
      * identifier
    )
]

and anon_choice_pat_29be9ad = [
    `Pat of pattern
  | `Slice_pat of Token.t (* ".." *)
]

and anon_opt_exp_rep_interp_alig_clause_cd88eaa =
  (expression * interpolation_alignment_clause list (* zero or more *))
    option

and anonymous_object_member_declarator = [
    `Name_equals_exp of (name_equals * expression)
  | `Exp of expression
]

and argument = [
    `Opt_name_colon_opt_choice_ref_choice_exp of (
        name_colon option
      * anon_choice_ref_eec35e8 option
      * [ `Exp of expression | `Decl_exp of declaration_expression ]
    )
  | `Semg_vari_meta of semgrep_variadic_metavariable (*tok*)
]

and argument_list = (
    Token.t (* "(" *)
  * (argument * (Token.t (* "," *) * argument) list (* zero or more *))
      option
  * Token.t (* ")" *)
)

and array_base_type = [
    `Array_type of array_type
  | `Type_name of type_name
  | `Null_type of nullable_type
  | `Poin_type of pointer_type
  | `Func_poin_type of function_pointer_type
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of tuple_type
]

and array_rank_specifier = (
    Token.t (* "[" *)
  * (
        expression option
      * (Token.t (* "," *) * expression option) list (* zero or more *)
    )
      option
  * Token.t (* "]" *)
)

and array_type = (array_base_type * array_rank_specifier)

and arrow_expression_clause = (Token.t (* "=>" *) * expression)

and attribute = (type_name * attribute_argument_list option)

and attribute_argument = (
    [ `Name_equals of name_equals | `Name_colon of name_colon ] option
  * expression
)

and attribute_argument_list = (
    Token.t (* "(" *)
  * (
        attribute_argument
      * (Token.t (* "," *) * attribute_argument) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and attribute_list = (
    Token.t (* "[" *)
  * attribute_target_specifier option
  * attribute
  * (Token.t (* "," *) * attribute) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

and binary_expression = [
    `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Exp_GTGTGT_exp of (expression * Token.t (* ">>>" *) * expression)
  | `Exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
  | `Exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Exp_GT_exp of (expression * Token.t (* ">" *) * expression)
  | `Exp_QMARKQMARK_exp of (expression * Token.t (* "??" *) * expression)
]

and block = (
    Token.t (* "{" *)
  * global_statement list (* zero or more *)
  * Token.t (* "}" *)
)

and bracketed_argument_list = (
    Token.t (* "[" *)
  * argument
  * (Token.t (* "," *) * argument) list (* zero or more *)
  * Token.t (* "]" *)
)

and case_pattern_switch_label = (
    Token.t (* "case" *)
  * pattern
  * when_clause option
  * Token.t (* ":" *)
)

and case_switch_label = (
    Token.t (* "case" *) * expression * Token.t (* ":" *)
)

and cast_expression = (
    Token.t (* "(" *) * type_pattern * Token.t (* ")" *) * expression
)

and catch_clause = (
    Token.t (* "catch" *)
  * catch_declaration option
  * catch_filter_clause option
  * block
)

and catch_declaration = (
    Token.t (* "(" *)
  * type_pattern
  * identifier option
  * Token.t (* ")" *)
)

and catch_filter_clause = (
    Token.t (* "when" *) * Token.t (* "(" *) * expression * Token.t (* ")" *)
)

and checked_expression = [
    `Chec_LPAR_exp_RPAR of (
        Token.t (* "checked" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *)
    )
  | `Unch_LPAR_exp_RPAR of (
        Token.t (* "unchecked" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *)
    )
]

and constant_pattern = [
    `Bin_exp of binary_expression
  | `Defa_exp of default_expression
  | `Inte_str_exp of interpolated_string_expression
  | `Paren_exp of parenthesized_expression
  | `Post_un_exp of postfix_unary_expression
  | `Prefix_un_exp of prefix_unary_expression
  | `Size_of_exp of size_of_expression
  | `Tuple_exp of tuple_expression
  | `Type_of_exp of type_of_expression
  | `Member_access_exp of member_access_expression
  | `Invo_exp of invocation_expression
  | `Cast_exp of cast_expression
  | `Simple_name of simple_name
  | `Lit of literal
]

and declaration_expression = (type_pattern * identifier)

and deep_ellipsis = (
    Token.t (* "<..." *) * expression * Token.t (* "...>" *)
)

and default_expression = (
    Token.t (* "default" *)
  * (Token.t (* "(" *) * type_pattern * Token.t (* ")" *)) option
)

and element_binding_expression = bracketed_argument_list

and equals_value_clause = (Token.t (* "=" *) * expression)

and expression = [
    `Non_lvalue_exp of non_lvalue_expression
  | `Lvalue_exp of lvalue_expression
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips of deep_ellipsis
  | `Member_access_ellips_exp of member_access_ellipsis_expression
  | `Typed_meta of typed_metavariable
]

and expression_colon = (expression * Token.t (* ":" *))

and expression_statement = [
    `Exp_stmt_exp_SEMI of (
        expression_statement_expression * Token.t (* ";" *)
    )
  | `Ellips_SEMI of (Token.t (* "..." *) * Token.t (* ";" *))
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips_SEMI of (deep_ellipsis * Token.t (* ";" *))
  | `Member_access_ellips_exp_SEMI of (
        member_access_ellipsis_expression * Token.t (* ";" *)
    )
  | `Semg_meta_SEMI of (semgrep_metavariable (*tok*) * Token.t (* ";" *))
  | `Typed_meta_SEMI of (typed_metavariable * Token.t (* ";" *))
]

and expression_statement_expression = [
    `Assign_exp of (lvalue_expression * assignment_operator * expression)
  | `Invo_exp of invocation_expression
  | `Post_un_exp of postfix_unary_expression
  | `Prefix_un_exp of prefix_unary_expression
  | `Await_exp of (Token.t (* "await" *) * expression)
  | `Obj_crea_exp of (
        Token.t (* "new" *)
      * object_creation_type
      * argument_list option
      * initializer_expression option
    )
  | `Paren_exp of parenthesized_expression
]

and finally_clause = (Token.t (* "finally" *) * block)

and formal_parameter_list = (
    anon_choice_param_ce11a32
  * (Token.t (* "," *) * anon_choice_param_ce11a32) list (* zero or more *)
)

and from_clause = (
    Token.t (* "from" *)
  * type_pattern option
  * identifier
  * Token.t (* "in" *)
  * expression
)

and function_body = [
    `Blk of block
  | `Arrow_exp_clause_SEMI of (arrow_expression_clause * Token.t (* ";" *))
  | `SEMI of Token.t (* ";" *)
]

and function_pointer_parameter = (
    anon_choice_ref_eec35e8 option
  * ref_base_type
)

and function_pointer_return_type = type_

and function_pointer_type = (
    Token.t (* "delegate" *)
  * Token.t (* "*" *)
  * function_pointer_calling_convention option
  * Token.t (* "<" *)
  * (function_pointer_parameter * Token.t (* "," *)) list (* zero or more *)
  * function_pointer_return_type
  * Token.t (* ">" *)
)

and global_statement = statement

and initializer_expression = (
    Token.t (* "{" *)
  * anon_opt_exp_rep_interp_alig_clause_cd88eaa
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and interpolated_raw_string_content = [
    `Inte_raw_str_text of interpolated_raw_string_text
  | `Interp of interpolation
]

and interpolated_string_content = [
    `Inte_str_text of interpolated_string_text
  | `Interp of interpolation
]

and interpolated_string_expression = [
    `DOLLARDQUOT_rep_inte_str_content_DQUOT of (
        Token.t (* "$\"" *)
      * interpolated_string_content list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `DOLLARATDQUOT_rep_inte_verb_str_content_DQUOT of (
        Token.t (* "$@\"" *)
      * interpolated_verbatim_string_content list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `ATDOLLARDQUOT_rep_inte_verb_str_content_DQUOT of (
        Token.t (* "@$\"" *)
      * interpolated_verbatim_string_content list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `DOLLARDQUOTDQUOTDQUOT_rep_inte_raw_str_content_DQUOTDQUOTDQUOT of (
        Token.t (* "$\"\"\"" *)
      * interpolated_raw_string_content list (* zero or more *)
      * Token.t (* "\"\"\"" *)
    )
]

and interpolated_verbatim_string_content = [
    `Inte_verb_str_text of interpolated_verbatim_string_text
  | `Interp of interpolation
]

and interpolation = (
    Token.t (* "{" *)
  * expression
  * interpolation_alignment_clause option
  * interpolation_format_clause option
  * Token.t (* "}" *)
)

and interpolation_alignment_clause = (Token.t (* "," *) * expression)

and invocation_expression = (expression * argument_list)

and lvalue_expression = [
    `This_exp of Token.t (* "this" *)
  | `Member_access_exp of member_access_expression
  | `Tuple_exp of tuple_expression
  | `Simple_name of simple_name
  | `Elem_access_exp of (expression * element_binding_expression)
  | `Elem_bind_exp of element_binding_expression
  | `Poin_indi_exp of (Token.t (* "*" *) * expression)
  | `Paren_lvalue_exp of (
        Token.t (* "(" *) * lvalue_expression * Token.t (* ")" *)
    )
]

and member_access_ellipsis_expression = (
    anon_choice_exp_3bb8381 * anon_choice_DOT_2ad1dab * Token.t (* "..." *)
)

and member_access_expression = (
    anon_choice_exp_3bb8381 * anon_choice_DOT_2ad1dab * simple_name
)

and member_binding_expression = (Token.t (* "." *) * simple_name)

and name = [
    `Alias_qual_name of (
        identifier_or_global * Token.t (* "::" *) * simple_name
    )
  | `Qual_name of (type_name * Token.t (* "." *) * simple_name)
  | `Simple_name of simple_name
]

and non_lvalue_expression = [
    `Anon_meth_exp of (
        anon_choice_async_25087f5 option
      * Token.t (* "delegate" *)
      * parameter_list option
      * block
    )
  | `Anon_obj_crea_exp of (
        Token.t (* "new" *)
      * Token.t (* "{" *)
      * (
            anonymous_object_member_declarator
          * (Token.t (* "," *) * anonymous_object_member_declarator)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Array_crea_exp of (
        Token.t (* "new" *)
      * array_type
      * initializer_expression option
    )
  | `As_exp of (expression * Token.t (* "as" *) * type_pattern)
  | `Base_exp of Token.t (* "base" *)
  | `Bin_exp of binary_expression
  | `Cast_exp of cast_expression
  | `Chec_exp of checked_expression
  | `Cond_access_exp of (
        expression
      * Token.t (* "?" *)
      * [
            `Member_bind_exp of member_binding_expression
          | `Elem_bind_exp of element_binding_expression
        ]
    )
  | `Cond_exp of (
        expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
      * expression
    )
  | `Defa_exp of default_expression
  | `Impl_array_crea_exp of (
        Token.t (* "new" *)
      * Token.t (* "[" *)
      * Token.t (* "," *) list (* zero or more *)
      * Token.t (* "]" *)
      * initializer_expression
    )
  | `Impl_obj_crea_exp of (
        Token.t (* "new" *)
      * argument_list
      * initializer_expression option
    )
  | `Impl_stack_alloc_array_crea_exp of (
        Token.t (* "stackalloc" *) * Token.t (* "[" *) * Token.t (* "]" *)
      * initializer_expression
    )
  | `Init_exp of initializer_expression
  | `Inte_str_exp of interpolated_string_expression
  | `Is_exp of (expression * Token.t (* "is" *) * type_pattern)
  | `Is_pat_exp of (expression * Token.t (* "is" *) * pattern)
  | `Lambda_exp of (
        attribute_list list (* zero or more *)
      * anon_choice_async_25087f5 option
      * type_pattern option
      * [ `Param_list of parameter_list | `Id of identifier ]
      * Token.t (* "=>" *)
      * [ `Blk of block | `Exp of expression ]
    )
  | `Make_ref_exp of (
        Token.t (* "__makeref" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *)
    )
  | `Query_exp of (from_clause * query_body)
  | `Range_exp of (
        expression option
      * Token.t (* ".." *)
      * expression option
    )
  | `Ref_exp of (Token.t (* "ref" *) * expression)
  | `Ref_type_exp of (
        Token.t (* "__reftype" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *)
    )
  | `Ref_value_exp of (
        Token.t (* "__refvalue" *) * Token.t (* "(" *) * expression
      * Token.t (* "," *) * type_pattern * Token.t (* ")" *)
    )
  | `Size_of_exp of size_of_expression
  | `Stack_alloc_array_crea_exp of (
        Token.t (* "stackalloc" *)
      * array_type
      * initializer_expression option
    )
  | `Switch_exp of (
        expression
      * Token.t (* "switch" *)
      * Token.t (* "{" *)
      * (
            switch_expression_arm
          * (Token.t (* "," *) * switch_expression_arm)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Throw_exp of (Token.t (* "throw" *) * expression)
  | `Type_of_exp of type_of_expression
  | `With_exp of (
        expression
      * Token.t (* "with" *)
      * Token.t (* "{" *)
      * with_initializer_expression option
      * Token.t (* "}" *)
    )
  | `Lit of literal
  | `Exp_stmt_exp of expression_statement_expression
]

and nullable_base_type = [
    `Array_type of array_type
  | `Type_name of type_name
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of tuple_type
]

and nullable_type = (nullable_base_type * Token.t (* "?" *))

and object_creation_type = [
    `Type_name of type_name
  | `Null_type of nullable_type
  | `Pred_type of predefined_type (*tok*)
]

and ordering = (
    expression
  * [
        `Asce of Token.t (* "ascending" *)
      | `Desc of Token.t (* "descending" *)
    ]
      option
)

and parameter = [
    `Rep_attr_list_opt_param_type_with_modifs_id_opt_equals_value_clause of (
        attribute_list list (* zero or more *)
      * parameter_type_with_modifiers option
      * identifier
      * equals_value_clause option
    )
  | `Ellips of Token.t (* "..." *)
]

and parameter_list = (
    Token.t (* "(" *)
  * formal_parameter_list option
  * Token.t (* ")" *)
)

and parameter_type_with_modifiers = (
    Token.t (* "this" *) option
  * Token.t (* "scoped" *) option
  * anon_choice_ref_eec35e8 option
  * ref_base_type
)

and parenthesized_expression = (
    Token.t (* "(" *) * non_lvalue_expression * Token.t (* ")" *)
)

and pattern = [
    `Cst_pat of constant_pattern
  | `Decl_pat of (type_pattern * variable_designation)
  | `Disc of Token.t (* "_" *)
  | `Recu_pat of (
        type_pattern option
      * [
            `Posi_pat_clause_opt_prop_pat_clause of (
                positional_pattern_clause
              * property_pattern_clause option
            )
          | `Prop_pat_clause of property_pattern_clause
        ]
      * variable_designation option
    )
  | `Var_pat of (Token.t (* "var" *) * variable_designation)
  | `Nega_pat of (Token.t (* "not" *) * pattern)
  | `Paren_pat of (Token.t (* "(" *) * pattern * Token.t (* ")" *))
  | `Rela_pat of relational_pattern
  | `Or_pat of (pattern * Token.t (* "or" *) * pattern)
  | `And_pat of (pattern * Token.t (* "and" *) * pattern)
  | `List_pat of (
        Token.t (* "[" *)
      * (
            anon_choice_pat_29be9ad
          * (Token.t (* "," *) * anon_choice_pat_29be9ad)
              list (* zero or more *)
          * Token.t (* "," *) option
        )
          option
      * Token.t (* "]" *)
    )
  | `Type_pat of type_pattern
]

and pointer_base_type = [
    `Type_name of type_name
  | `Null_type of nullable_type
  | `Poin_type of pointer_type
  | `Func_poin_type of function_pointer_type
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of tuple_type
]

and pointer_type = (pointer_base_type * Token.t (* "*" *))

and positional_pattern_clause = (
    Token.t (* "(" *)
  * (
        subpattern
      * Token.t (* "," *)
      * subpattern
      * (Token.t (* "," *) * subpattern) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and postfix_unary_expression = [
    `Exp_PLUSPLUS of (expression * Token.t (* "++" *))
  | `Exp_DASHDASH of (expression * Token.t (* "--" *))
  | `Exp_BANG of (expression * Token.t (* "!" *))
]

and prefix_unary_expression = [
    `BANG_exp of (Token.t (* "!" *) * expression)
  | `AMP_exp of (Token.t (* "&" *) * expression)
  | `PLUS_exp of (Token.t (* "+" *) * expression)
  | `PLUSPLUS_exp of (Token.t (* "++" *) * expression)
  | `DASH_exp of (Token.t (* "-" *) * expression)
  | `DASHDASH_exp of (Token.t (* "--" *) * expression)
  | `HAT_exp of (Token.t (* "^" *) * expression)
  | `TILDE_exp of (Token.t (* "~" *) * expression)
]

and property_pattern_clause = (
    Token.t (* "{" *)
  * (subpattern * (Token.t (* "," *) * subpattern) list (* zero or more *))
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and query_body = [
  `Rectype of (
      query_clause list (* zero or more *)
    * select_or_group_clause
    * query_continuation option
  )
]

and query_clause = [
    `From_clause of from_clause
  | `Join_clause of (
        Token.t (* "join" *)
      * type_pattern option
      * identifier
      * Token.t (* "in" *)
      * expression
      * Token.t (* "on" *)
      * expression
      * Token.t (* "equals" *)
      * expression
      * join_into_clause option
    )
  | `Let_clause of (
        Token.t (* "let" *) * identifier * Token.t (* "=" *) * expression
    )
  | `Order_by_clause of (
        Token.t (* "orderby" *)
      * ordering
      * (Token.t (* "," *) * ordering) list (* zero or more *)
    )
  | `Where_clause of (Token.t (* "where" *) * expression)
]

and query_continuation = [
  `Rectype of (Token.t (* "into" *) * identifier * query_body)
]

and ref_base_type = [
    `Impl_type of Token.t (* "var" *)
  | `Array_type of array_type
  | `Type_name of type_name
  | `Null_type of nullable_type
  | `Poin_type of pointer_type
  | `Func_poin_type of function_pointer_type
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of tuple_type
]

and ref_type = (
    Token.t (* "ref" *)
  * Token.t (* "readonly" *) option
  * ref_base_type
)

and relational_pattern = [
    `LT_exp of (Token.t (* "<" *) * expression)
  | `LTEQ_exp of (Token.t (* "<=" *) * expression)
  | `GT_exp of (Token.t (* ">" *) * expression)
  | `GTEQ_exp of (Token.t (* ">=" *) * expression)
]

and scoped_base_type = [ `Type_name of type_name | `Ref_type of ref_type ]

and select_or_group_clause = [
    `Group_clause of (
        Token.t (* "group" *) * expression * Token.t (* "by" *) * expression
    )
  | `Select_clause of (Token.t (* "select" *) * expression)
]

and simple_assignment_expression = (
    identifier * Token.t (* "=" *) * expression
)

and simple_name = [
    `Gene_name of (identifier * type_argument_list)
  | `Choice_global of identifier_or_global
]

and size_of_expression = (
    Token.t (* "sizeof" *) * Token.t (* "(" *) * type_pattern
  * Token.t (* ")" *)
)

and statement = [
    `Blk of block
  | `Brk_stmt of (Token.t (* "break" *) * Token.t (* ";" *))
  | `Chec_stmt of (
        [
            `Chec of Token.t (* "checked" *)
          | `Unch of Token.t (* "unchecked" *)
        ]
      * block
    )
  | `Cont_stmt of (Token.t (* "continue" *) * Token.t (* ";" *))
  | `Do_stmt of (
        Token.t (* "do" *) * global_statement * Token.t (* "while" *)
      * Token.t (* "(" *) * expression * Token.t (* ")" *)
      * Token.t (* ";" *)
    )
  | `Empty_stmt of Token.t (* ";" *)
  | `Exp_stmt of expression_statement
  | `Fixed_stmt of (
        Token.t (* "fixed" *) * Token.t (* "(" *) * variable_declaration
      * Token.t (* ")" *) * global_statement
    )
  | `For_each_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "foreach" *)
      * Token.t (* "(" *)
      * [
            `Type_choice_id of (type_pattern * anon_choice_id_bf14316)
          | `Exp of expression
        ]
      * Token.t (* "in" *)
      * expression
      * Token.t (* ")" *)
      * global_statement
    )
  | `For_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * [
            `Var_decl of variable_declaration
          | `Exp_rep_COMMA_exp of (
                expression
              * interpolation_alignment_clause list (* zero or more *)
            )
        ]
          option
      * Token.t (* ";" *)
      * expression option
      * Token.t (* ";" *)
      * anon_opt_exp_rep_interp_alig_clause_cd88eaa
      * Token.t (* ")" *)
      * global_statement
    )
  | `Goto_stmt of (
        Token.t (* "goto" *)
      * [ `Case of Token.t (* "case" *) | `Defa of Token.t (* "default" *) ]
          option
      * expression option
      * Token.t (* ";" *)
    )
  | `If_stmt of (
        Token.t (* "if" *)
      * Token.t (* "(" *)
      * expression
      * Token.t (* ")" *)
      * global_statement
      * (Token.t (* "else" *) * global_statement) option
    )
  | `Labe_stmt of (identifier * Token.t (* ":" *) * global_statement)
  | `Local_decl_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "using" *) option
      * modifier list (* zero or more *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Local_func_stmt of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * identifier
      * type_parameter_list option
      * parameter_list
      * type_parameter_constraints_clause list (* zero or more *)
      * function_body
    )
  | `Lock_stmt of (
        Token.t (* "lock" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *) * global_statement
    )
  | `Ret_stmt of (
        Token.t (* "return" *)
      * expression option
      * Token.t (* ";" *)
    )
  | `Switch_stmt of (
        Token.t (* "switch" *)
      * [
            `LPAR_exp_RPAR of (
                Token.t (* "(" *) * expression * Token.t (* ")" *)
            )
          | `Tuple_exp of tuple_expression
        ]
      * switch_body
    )
  | `Throw_stmt of (
        Token.t (* "throw" *)
      * expression option
      * Token.t (* ";" *)
    )
  | `Try_stmt of (
        Token.t (* "try" *)
      * block
      * catch_clause list (* zero or more *)
      * finally_clause option
    )
  | `Unsafe_stmt of (Token.t (* "unsafe" *) * block)
  | `Using_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "using" *)
      * Token.t (* "(" *)
      * [ `Var_decl of variable_declaration | `Exp of expression ]
      * Token.t (* ")" *)
      * global_statement
    )
  | `While_stmt of (
        Token.t (* "while" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *) * global_statement
    )
  | `Yield_stmt of (
        Token.t (* "yield" *)
      * [
            `Ret_exp of (Token.t (* "return" *) * expression)
          | `Brk of Token.t (* "break" *)
        ]
      * Token.t (* ";" *)
    )
]

and subpattern = (expression_colon option * pattern)

and switch_body = (
    Token.t (* "{" *)
  * switch_section list (* zero or more *)
  * Token.t (* "}" *)
)

and switch_expression_arm = (
    pattern
  * when_clause option
  * Token.t (* "=>" *)
  * expression
)

and switch_section = (
    [
        `Case_switch_label of case_switch_label
      | `Case_pat_switch_label of case_pattern_switch_label
      | `Defa_switch_label of default_switch_label
    ]
      list (* one or more *)
  * global_statement list (* one or more *)
)

and tuple_element = (type_pattern * identifier option)

and tuple_expression = (
    Token.t (* "(" *)
  * argument
  * Token.t (* "," *)
  * argument
  * (Token.t (* "," *) * argument) list (* zero or more *)
  * Token.t (* ")" *)
)

and tuple_type = (
    Token.t (* "(" *)
  * tuple_element
  * Token.t (* "," *)
  * tuple_element
  * (Token.t (* "," *) * tuple_element) list (* zero or more *)
  * Token.t (* ")" *)
)

and type_ = [
    `Impl_type of Token.t (* "var" *)
  | `Array_type of array_type
  | `Type_name of type_name
  | `Null_type of nullable_type
  | `Poin_type of pointer_type
  | `Func_poin_type of function_pointer_type
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of tuple_type
  | `Ref_type of ref_type
  | `Scoped_type of (Token.t (* "scoped" *) * scoped_base_type)
]

and type_argument_list = (
    Token.t (* "<" *)
  * [
        `Rep_COMMA of Token.t (* "," *) list (* zero or more *)
      | `Type_rep_COMMA_type of (
            type_pattern
          * (Token.t (* "," *) * type_pattern) list (* zero or more *)
        )
    ]
  * Token.t (* ">" *)
)

and type_constraint = type_

and type_name = name

and type_of_expression = (
    Token.t (* "typeof" *) * Token.t (* "(" *) * type_pattern
  * Token.t (* ")" *)
)

and type_parameter = (
    attribute_list list (* zero or more *)
  * [ `In of Token.t (* "in" *) | `Out of Token.t (* "out" *) ] option
  * identifier
)

and type_parameter_constraint = [
    `Class_opt_QMARK of (Token.t (* "class" *) * Token.t (* "?" *) option)
  | `Struct of Token.t (* "struct" *)
  | `Notn of Token.t (* "notnull" *)
  | `Unma of Token.t (* "unmanaged" *)
  | `Cons_cons of (
        Token.t (* "new" *) * Token.t (* "(" *) * Token.t (* ")" *)
    )
  | `Type_cons of type_constraint
]

and type_parameter_constraints_clause = (
    Token.t (* "where" *)
  * identifier_or_global
  * Token.t (* ":" *)
  * type_parameter_constraint
  * (Token.t (* "," *) * type_parameter_constraint) list (* zero or more *)
)

and type_parameter_list = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* ">" *)
)

and type_pattern = type_

and typed_metavariable = (
    Token.t (* "(" *) * type_pattern * semgrep_metavariable (*tok*)
  * Token.t (* ")" *)
)

and variable_declaration = (
    type_pattern
  * variable_declarator
  * (Token.t (* "," *) * variable_declarator) list (* zero or more *)
)

and variable_declarator = (
    anon_choice_id_bf14316
  * element_binding_expression option
  * equals_value_clause option
)

and when_clause = (Token.t (* "when" *) * expression)

and with_initializer_expression = (
    simple_assignment_expression
  * (Token.t (* "," *) * simple_assignment_expression)
      list (* zero or more *)
)

type bracketed_parameter_list = (
    Token.t (* "[" *) * formal_parameter_list * Token.t (* "]" *)
)

type base_list = (
    Token.t (* ":" *)
  * type_pattern
  * (Token.t (* "," *) * type_pattern) list (* zero or more *)
)

type explicit_interface_specifier = (type_name * Token.t (* "." *))

type constructor_initializer = (
    Token.t (* ":" *)
  * [ `Base of Token.t (* "base" *) | `This of Token.t (* "this" *) ]
  * argument_list
)

type primary_constructor_base_type = (type_name * argument_list)

type using_directive = (
    Token.t (* "global" *) option
  * Token.t (* "using" *)
  * [ `Static of Token.t (* "static" *) | `Name_equals of name_equals ]
      option
  * type_name
  * Token.t (* ";" *)
)

type global_attribute_list = (
    Token.t (* "[" *)
  * [ `Asse of Token.t (* "assembly" *) | `Module of Token.t (* "module" *) ]
  * Token.t (* ":" *)
  * (attribute * (Token.t (* "," *) * attribute) list (* zero or more *))
      option
  * Token.t (* "]" *)
)

type accessor_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * [
        `Get of Token.t (* "get" *)
      | `Set of Token.t (* "set" *)
      | `Add of Token.t (* "add" *)
      | `Remove of Token.t (* "remove" *)
      | `Init of Token.t (* "init" *)
      | `Id of identifier
    ]
  * function_body
)

type enum_member_declaration = [
    `Rep_attr_list_id_opt_EQ_exp of (
        attribute_list list (* zero or more *)
      * identifier
      * equals_value_clause option
    )
  | `Ellips of Token.t (* "..." *)
]

type delegate_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "delegate" *)
  * type_pattern
  * identifier
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * Token.t (* ";" *)
)

type record_base = [
    `COLON_type_name_rep_COMMA_type_name of (
        Token.t (* ":" *)
      * type_name
      * (Token.t (* "," *) * type_name) list (* zero or more *)
    )
  | `COLON_prim_cons_base_type_opt_COMMA_type_name_rep_COMMA_type_name of (
        Token.t (* ":" *)
      * primary_constructor_base_type
      * (
            Token.t (* "," *)
          * type_name
          * (Token.t (* "," *) * type_name) list (* zero or more *)
        )
          option
    )
]

type accessor_list = (
    Token.t (* "{" *)
  * accessor_declaration list (* zero or more *)
  * Token.t (* "}" *)
)

type enum_member_declaration_list = (
    Token.t (* "{" *)
  * (
        enum_member_declaration
      * (Token.t (* "," *) * enum_member_declaration) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type enum_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "enum" *)
  * identifier
  * base_list option
  * enum_member_declaration_list
  * opt_semi (*tok*)
)

type class_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "class" *)
  * identifier
  * type_parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * opt_semi (*tok*)
)

and declaration = [
    `Class_decl of class_declaration
  | `Cons_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * identifier
      * parameter_list
      * constructor_initializer option
      * function_body
    )
  | `Conv_op_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * [
            `Impl of Token.t (* "implicit" *)
          | `Expl of Token.t (* "explicit" *)
        ]
      * explicit_interface_specifier option
      * Token.t (* "operator" *)
      * Token.t (* "checked" *) option
      * type_pattern
      * parameter_list
      * function_body
    )
  | `Dele_decl of delegate_declaration
  | `Dest_decl of (
        attribute_list list (* zero or more *)
      * Token.t (* "extern" *) option
      * Token.t (* "~" *)
      * identifier
      * parameter_list
      * function_body
    )
  | `Enum_decl of enum_declaration
  | `Event_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "event" *)
      * type_pattern
      * explicit_interface_specifier option
      * identifier
      * [ `Acce_list of accessor_list | `SEMI of Token.t (* ";" *) ]
    )
  | `Event_field_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "event" *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Field_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Inde_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * explicit_interface_specifier option
      * Token.t (* "this" *)
      * bracketed_parameter_list
      * [
            `Acce_list of accessor_list
          | `Arrow_exp_clause_SEMI of (
                arrow_expression_clause * Token.t (* ";" *)
            )
        ]
    )
  | `Inte_decl of interface_declaration
  | `Meth_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * explicit_interface_specifier option
      * identifier
      * type_parameter_list option
      * parameter_list
      * type_parameter_constraints_clause list (* zero or more *)
      * function_body
    )
  | `Name_decl of namespace_declaration
  | `Op_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * explicit_interface_specifier option
      * Token.t (* "operator" *)
      * Token.t (* "checked" *) option
      * overloadable_operator
      * parameter_list
      * function_body
    )
  | `Prop_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * explicit_interface_specifier option
      * identifier
      * [
            `Acce_list_opt_EQ_exp_SEMI of (
                accessor_list
              * (Token.t (* "=" *) * expression * Token.t (* ";" *)) option
            )
          | `Arrow_exp_clause_SEMI of (
                arrow_expression_clause * Token.t (* ";" *)
            )
        ]
    )
  | `Record_decl of record_declaration
  | `Record_struct_decl of record_struct_declaration
  | `Struct_decl of struct_declaration
  | `Using_dire of using_directive
  | `Ellips of Token.t (* "..." *)
]

and declaration_list = (
    Token.t (* "{" *)
  * declaration list (* zero or more *)
  * Token.t (* "}" *)
)

and interface_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "interface" *)
  * identifier
  * type_parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * opt_semi (*tok*)
)

and namespace_declaration = (
    Token.t (* "namespace" *) * type_name * declaration_list
  * opt_semi (*tok*)
)

and record_body = [
    `Decl_list of declaration_list
  | `SEMI of Token.t (* ";" *)
]

and record_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "record" *)
  * Token.t (* "class" *) option
  * identifier
  * type_parameter_list option
  * parameter_list option
  * record_base option
  * type_parameter_constraints_clause list (* zero or more *)
  * record_body
  * opt_semi (*tok*)
)

and record_struct_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "record" *)
  * Token.t (* "struct" *)
  * identifier
  * type_parameter_list option
  * parameter_list option
  * record_base option
  * type_parameter_constraints_clause list (* zero or more *)
  * record_body
  * opt_semi (*tok*)
)

and struct_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "ref" *) option
  * Token.t (* "struct" *)
  * identifier
  * type_parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * opt_semi (*tok*)
)

type type_declaration = [
    `Class_decl of class_declaration
  | `Struct_decl of struct_declaration
  | `Inte_decl of interface_declaration
  | `Enum_decl of enum_declaration
  | `Dele_decl of delegate_declaration
  | `Record_decl of record_declaration
  | `Record_struct_decl of record_struct_declaration
]

type namespace_member_declaration = [
    `Name_decl of namespace_declaration
  | `Type_decl of type_declaration
]

type file_scoped_namespace_declaration = (
    Token.t (* "namespace" *)
  * type_name
  * Token.t (* ";" *)
  * extern_alias_directive list (* zero or more *)
  * using_directive list (* zero or more *)
  * type_declaration list (* zero or more *)
)

type compilation_unit = [
    `Rep_extern_alias_dire_rep_using_dire_rep_global_attr_list_choice_rep_global_stmt_rep_name_member_decl of (
        extern_alias_directive list (* zero or more *)
      * using_directive list (* zero or more *)
      * global_attribute_list list (* zero or more *)
      * [
            `Rep_global_stmt_rep_name_member_decl of (
                global_statement list (* zero or more *)
              * namespace_member_declaration list (* zero or more *)
            )
          | `File_scoped_name_decl of file_scoped_namespace_declaration
        ]
    )
  | `Semg_exp of (Token.t (* "__SEMGREP_EXPRESSION" *) * expression)
]

type continue_statement (* inlined *) = (
    Token.t (* "continue" *) * Token.t (* ";" *)
)

type global (* inlined *) = Token.t (* "global" *)

type break_statement (* inlined *) = (
    Token.t (* "break" *) * Token.t (* ";" *)
)

type discard (* inlined *) = Token.t (* "_" *)

type parameter_modifier (* inlined *) = [
    `Ref of Token.t (* "ref" *)
  | `Out of Token.t (* "out" *)
  | `This of Token.t (* "this" *)
  | `In of Token.t (* "in" *)
  | `Scoped of Token.t (* "scoped" *)
]

type constructor_constraint (* inlined *) = (
    Token.t (* "new" *) * Token.t (* "(" *) * Token.t (* ")" *)
)

type this_expression (* inlined *) = Token.t (* "this" *)

type endif_directive (* inlined *) = Token.t (* "endif" *)

type null_literal (* inlined *) = Token.t (* "null" *)

type slice_pattern (* inlined *) = Token.t (* ".." *)

type base_expression (* inlined *) = Token.t (* "base" *)

type comment (* inlined *) = Token.t

type implicit_type (* inlined *) = Token.t (* "var" *)

type else_directive (* inlined *) = Token.t (* "else" *)

type ellipsis (* inlined *) = Token.t (* "..." *)

type empty_statement (* inlined *) = Token.t (* ";" *)

type string_literal (* inlined *) = (
    Token.t (* "\"" *)
  * [
        `Str_lit_frag of string_literal_fragment (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
    ]
      list (* zero or more *)
  * Token.t (* "\"" *)
  * string_literal_encoding (*tok*) option
)

type character_literal (* inlined *) = (
    Token.t (* "'" *)
  * [
        `Char_lit_unes of character_literal_unescaped (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
    ]
  * Token.t (* "'" *)
)

type parenthesized_variable_designation (* inlined *) = (
    Token.t (* "(" *)
  * (
        variable_designation
      * (Token.t (* "," *) * variable_designation) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

type preproc_parenthesized_expression (* inlined *) = (
    Token.t (* "(" *) * preproc_expression * Token.t (* ")" *)
)

type preproc_unary_expression (* inlined *) = (
    Token.t (* "!" *) * preproc_expression
)

type var_pattern (* inlined *) = (Token.t (* "var" *) * variable_designation)

type preprocessor_call (* inlined *) = (
    preproc_directive_start (*tok*)
  * [
        `Null_dire of nullable_directive
      | `Define_dire of define_directive
      | `Undef_dire of undef_directive
      | `If_dire of if_directive
      | `Else_dire of Token.t (* "else" *)
      | `Elif_dire of elif_directive
      | `Endif_dire of Token.t (* "endif" *)
      | `Region_dire of region_directive
      | `Endr_dire of endregion_directive
      | `Error_dire of error_directive
      | `Warn_dire of warning_directive
      | `Line_dire of line_directive
      | `Pragma_dire of pragma_directive
      | `Ref_dire of reference_directive
      | `Load_dire of load_directive
      | `Sheb_dire of shebang_directive
    ]
  * preproc_directive_end (*tok*)
)

type alias_qualified_name (* inlined *) = (
    identifier_or_global * Token.t (* "::" *) * simple_name
)

type and_pattern (* inlined *) = (pattern * Token.t (* "and" *) * pattern)

type anonymous_method_expression (* inlined *) = (
    anon_choice_async_25087f5 option
  * Token.t (* "delegate" *)
  * parameter_list option
  * block
)

type anonymous_object_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * Token.t (* "{" *)
  * (
        anonymous_object_member_declarator
      * (Token.t (* "," *) * anonymous_object_member_declarator)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type array_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * array_type
  * initializer_expression option
)

type as_expression (* inlined *) = (
    expression * Token.t (* "as" *) * type_pattern
)

type assignment_expression (* inlined *) = (
    lvalue_expression * assignment_operator * expression
)

type await_expression (* inlined *) = (Token.t (* "await" *) * expression)

type checked_statement (* inlined *) = (
    [ `Chec of Token.t (* "checked" *) | `Unch of Token.t (* "unchecked" *) ]
  * block
)

type conditional_access_expression (* inlined *) = (
    expression
  * Token.t (* "?" *)
  * [
        `Member_bind_exp of member_binding_expression
      | `Elem_bind_exp of element_binding_expression
    ]
)

type conditional_expression (* inlined *) = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * expression
)

type declaration_pattern (* inlined *) = (
    type_pattern * variable_designation
)

type do_statement (* inlined *) = (
    Token.t (* "do" *) * global_statement * Token.t (* "while" *)
  * Token.t (* "(" *) * expression * Token.t (* ")" *) * Token.t (* ";" *)
)

type element_access_expression (* inlined *) = (
    expression * element_binding_expression
)

type fixed_statement (* inlined *) = (
    Token.t (* "fixed" *) * Token.t (* "(" *) * variable_declaration
  * Token.t (* ")" *) * global_statement
)

type for_each_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "foreach" *)
  * Token.t (* "(" *)
  * [
        `Type_choice_id of (type_pattern * anon_choice_id_bf14316)
      | `Exp of expression
    ]
  * Token.t (* "in" *)
  * expression
  * Token.t (* ")" *)
  * global_statement
)

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * [
        `Var_decl of variable_declaration
      | `Exp_rep_COMMA_exp of (
            expression
          * interpolation_alignment_clause list (* zero or more *)
        )
    ]
      option
  * Token.t (* ";" *)
  * expression option
  * Token.t (* ";" *)
  * anon_opt_exp_rep_interp_alig_clause_cd88eaa
  * Token.t (* ")" *)
  * global_statement
)

type generic_name (* inlined *) = (identifier * type_argument_list)

type goto_statement (* inlined *) = (
    Token.t (* "goto" *)
  * [ `Case of Token.t (* "case" *) | `Defa of Token.t (* "default" *) ]
      option
  * expression option
  * Token.t (* ";" *)
)

type group_clause (* inlined *) = (
    Token.t (* "group" *) * expression * Token.t (* "by" *) * expression
)

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * Token.t (* "(" *)
  * expression
  * Token.t (* ")" *)
  * global_statement
  * (Token.t (* "else" *) * global_statement) option
)

type implicit_array_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * Token.t (* "[" *)
  * Token.t (* "," *) list (* zero or more *)
  * Token.t (* "]" *)
  * initializer_expression
)

type implicit_object_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * argument_list
  * initializer_expression option
)

type implicit_stack_alloc_array_creation_expression (* inlined *) = (
    Token.t (* "stackalloc" *) * Token.t (* "[" *) * Token.t (* "]" *)
  * initializer_expression
)

type is_expression (* inlined *) = (
    expression * Token.t (* "is" *) * type_pattern
)

type is_pattern_expression (* inlined *) = (
    expression * Token.t (* "is" *) * pattern
)

type join_clause (* inlined *) = (
    Token.t (* "join" *)
  * type_pattern option
  * identifier
  * Token.t (* "in" *)
  * expression
  * Token.t (* "on" *)
  * expression
  * Token.t (* "equals" *)
  * expression
  * join_into_clause option
)

type labeled_statement (* inlined *) = (
    identifier * Token.t (* ":" *) * global_statement
)

type lambda_expression (* inlined *) = (
    attribute_list list (* zero or more *)
  * anon_choice_async_25087f5 option
  * type_pattern option
  * [ `Param_list of parameter_list | `Id of identifier ]
  * Token.t (* "=>" *)
  * [ `Blk of block | `Exp of expression ]
)

type let_clause (* inlined *) = (
    Token.t (* "let" *) * identifier * Token.t (* "=" *) * expression
)

type list_pattern (* inlined *) = (
    Token.t (* "[" *)
  * (
        anon_choice_pat_29be9ad
      * (Token.t (* "," *) * anon_choice_pat_29be9ad) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "]" *)
)

type local_declaration_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "using" *) option
  * modifier list (* zero or more *)
  * variable_declaration
  * Token.t (* ";" *)
)

type local_function_statement (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * identifier
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * function_body
)

type lock_statement (* inlined *) = (
    Token.t (* "lock" *) * Token.t (* "(" *) * expression * Token.t (* ")" *)
  * global_statement
)

type make_ref_expression (* inlined *) = (
    Token.t (* "__makeref" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *)
)

type negated_pattern (* inlined *) = (Token.t (* "not" *) * pattern)

type object_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * object_creation_type
  * argument_list option
  * initializer_expression option
)

type or_pattern (* inlined *) = (pattern * Token.t (* "or" *) * pattern)

type order_by_clause (* inlined *) = (
    Token.t (* "orderby" *)
  * ordering
  * (Token.t (* "," *) * ordering) list (* zero or more *)
)

type parameter_array (* inlined *) = (
    attribute_list list (* zero or more *)
  * Token.t (* "params" *)
  * [ `Array_type of array_type | `Null_type of nullable_type ]
  * identifier
)

type parenthesized_lvalue_expression (* inlined *) = (
    Token.t (* "(" *) * lvalue_expression * Token.t (* ")" *)
)

type parenthesized_pattern (* inlined *) = (
    Token.t (* "(" *) * pattern * Token.t (* ")" *)
)

type pointer_indirection_expression (* inlined *) = (
    Token.t (* "*" *) * expression
)

type qualified_name (* inlined *) = (
    type_name * Token.t (* "." *) * simple_name
)

type query_expression (* inlined *) = (from_clause * query_body)

type range_expression (* inlined *) = (
    expression option
  * Token.t (* ".." *)
  * expression option
)

type recursive_pattern (* inlined *) = (
    type_pattern option
  * [
        `Posi_pat_clause_opt_prop_pat_clause of (
            positional_pattern_clause
          * property_pattern_clause option
        )
      | `Prop_pat_clause of property_pattern_clause
    ]
  * variable_designation option
)

type ref_expression (* inlined *) = (Token.t (* "ref" *) * expression)

type ref_type_expression (* inlined *) = (
    Token.t (* "__reftype" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *)
)

type ref_value_expression (* inlined *) = (
    Token.t (* "__refvalue" *) * Token.t (* "(" *) * expression
  * Token.t (* "," *) * type_pattern * Token.t (* ")" *)
)

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * expression option
  * Token.t (* ";" *)
)

type scoped_type (* inlined *) = (Token.t (* "scoped" *) * scoped_base_type)

type select_clause (* inlined *) = (Token.t (* "select" *) * expression)

type stack_alloc_array_creation_expression (* inlined *) = (
    Token.t (* "stackalloc" *)
  * array_type
  * initializer_expression option
)

type switch_expression (* inlined *) = (
    expression
  * Token.t (* "switch" *)
  * Token.t (* "{" *)
  * (
        switch_expression_arm
      * (Token.t (* "," *) * switch_expression_arm) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type switch_statement (* inlined *) = (
    Token.t (* "switch" *)
  * [
        `LPAR_exp_RPAR of (Token.t (* "(" *) * expression * Token.t (* ")" *))
      | `Tuple_exp of tuple_expression
    ]
  * switch_body
)

type throw_expression (* inlined *) = (Token.t (* "throw" *) * expression)

type throw_statement (* inlined *) = (
    Token.t (* "throw" *)
  * expression option
  * Token.t (* ";" *)
)

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * block
  * catch_clause list (* zero or more *)
  * finally_clause option
)

type unsafe_statement (* inlined *) = (Token.t (* "unsafe" *) * block)

type using_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "using" *)
  * Token.t (* "(" *)
  * [ `Var_decl of variable_declaration | `Exp of expression ]
  * Token.t (* ")" *)
  * global_statement
)

type where_clause (* inlined *) = (Token.t (* "where" *) * expression)

type while_statement (* inlined *) = (
    Token.t (* "while" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *) * global_statement
)

type with_expression (* inlined *) = (
    expression
  * Token.t (* "with" *)
  * Token.t (* "{" *)
  * with_initializer_expression option
  * Token.t (* "}" *)
)

type yield_statement (* inlined *) = (
    Token.t (* "yield" *)
  * [
        `Ret_exp of (Token.t (* "return" *) * expression)
      | `Brk of Token.t (* "break" *)
    ]
  * Token.t (* ";" *)
)

type destructor_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * Token.t (* "extern" *) option
  * Token.t (* "~" *)
  * identifier
  * parameter_list
  * function_body
)

type semgrep_expression (* inlined *) = (
    Token.t (* "__SEMGREP_EXPRESSION" *) * expression
)

type field_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * variable_declaration
  * Token.t (* ";" *)
)

type event_field_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "event" *)
  * variable_declaration
  * Token.t (* ";" *)
)

type operator_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * explicit_interface_specifier option
  * Token.t (* "operator" *)
  * Token.t (* "checked" *) option
  * overloadable_operator
  * parameter_list
  * function_body
)

type conversion_operator_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * [ `Impl of Token.t (* "implicit" *) | `Expl of Token.t (* "explicit" *) ]
  * explicit_interface_specifier option
  * Token.t (* "operator" *)
  * Token.t (* "checked" *) option
  * type_pattern
  * parameter_list
  * function_body
)

type method_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * explicit_interface_specifier option
  * identifier
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * function_body
)

type constructor_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * identifier
  * parameter_list
  * constructor_initializer option
  * function_body
)

type indexer_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * explicit_interface_specifier option
  * Token.t (* "this" *)
  * bracketed_parameter_list
  * [
        `Acce_list of accessor_list
      | `Arrow_exp_clause_SEMI of (
            arrow_expression_clause * Token.t (* ";" *)
        )
    ]
)

type property_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * explicit_interface_specifier option
  * identifier
  * [
        `Acce_list_opt_EQ_exp_SEMI of (
            accessor_list
          * (Token.t (* "=" *) * expression * Token.t (* ";" *)) option
        )
      | `Arrow_exp_clause_SEMI of (
            arrow_expression_clause * Token.t (* ";" *)
        )
    ]
)

type event_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "event" *)
  * type_pattern
  * explicit_interface_specifier option
  * identifier
  * [ `Acce_list of accessor_list | `SEMI of Token.t (* ";" *) ]
)
