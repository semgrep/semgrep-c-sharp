(* Generated by ocaml-tree-sitter. *)
(*
   c_sharp grammar

   entrypoint: compilation_unit
*)

open! Sexplib.Conv
open Tree_sitter_run

type pat_56631e5 = Token.t (* pattern #[ 	]*else *)

type real_literal = Token.t

type identifier_token = Token.t

type pat_52ffbd7 = Token.t (* pattern "[^}\"]+" *)

type pat_8a5c9c8 = Token.t (* pattern #[ 	]*error *)

type interpolation_close_brace = Token.t

type predefined_type = Token.t

type character_literal_content = Token.t (* pattern "[^'\\\\]" *)

type pat_c3ea183 = Token.t (* pattern #[ 	]*define *)

type raw_string_start = Token.t

type interpolation_end_quote = Token.t

type anon_choice_static_d4628a0 = [
    `Static of Token.t (* "static" *)
  | `Async of Token.t (* "async" *)
]

type pat_bfeb4bb = Token.t (* pattern #[ 	]*elif *)

type reserved_identifier = [
    `Alias of Token.t (* "alias" *)
  | `Asce of Token.t (* "ascending" *)
  | `By of Token.t (* "by" *)
  | `Desc of Token.t (* "descending" *)
  | `Equals of Token.t (* "equals" *)
  | `File of Token.t (* "file" *)
  | `From of Token.t (* "from" *)
  | `Global of Token.t (* "global" *)
  | `Group of Token.t (* "group" *)
  | `Into of Token.t (* "into" *)
  | `Join of Token.t (* "join" *)
  | `Let of Token.t (* "let" *)
  | `Notn of Token.t (* "notnull" *)
  | `On of Token.t (* "on" *)
  | `Orde of Token.t (* "orderby" *)
  | `Scoped of Token.t (* "scoped" *)
  | `Select of Token.t (* "select" *)
  | `Unma of Token.t (* "unmanaged" *)
  | `Var of Token.t (* "var" *)
  | `When of Token.t (* "when" *)
  | `Where of Token.t (* "where" *)
  | `Yield of Token.t (* "yield" *)
]

type raw_string_end = Token.t

type anon_choice_chec_7987657 = [
    `Chec of Token.t (* "checked" *)
  | `Unch of Token.t (* "unchecked" *)
]

type interpolation_start_quote = Token.t

type raw_string_content = Token.t

type pat_c46d1b2 = Token.t (* pattern #[ 	]*endif *)

type shebang_directive = Token.t

type imm_tok_bslash_pat_422e99f = Token.t

type attribute_target_specifier = (
    [
        `Field of Token.t (* "field" *)
      | `Event of Token.t (* "event" *)
      | `Meth of Token.t (* "method" *)
      | `Param of Token.t (* "param" *)
      | `Prop of Token.t (* "property" *)
      | `Ret of Token.t (* "return" *)
      | `Type of Token.t (* "type" *)
    ]
  * Token.t (* ":" *)
)

type preproc_arg = Token.t

type pat_721a115 = Token.t (* pattern #[ 	]*endregion *)

type pat_c1fe926 = Token.t (* pattern (u|U)8 *)

type pat_eb92600 = Token.t (* pattern #[ 	]*pragma *)

type pat_d299690 = Token.t (* pattern #[ 	]*line *)

type imm_tok_prec_p1_pat_5a6fa79 = Token.t (* pattern "[^\"\\\\\\n]+" *)

type interpolation_verbatim_start = Token.t

type pat_fdf8f81 = Token.t (* pattern #[ 	]*nullable *)

type pat_ca788a8 = Token.t (* pattern #[ 	]*warning *)

type semgrep_variadic_metavariable =
  Token.t (* pattern \$\.\.\.[A-Z_][A-Z_0-9]* *)

type interpolation_raw_start = Token.t

type pat_4946ad9 = Token.t (* pattern #[ 	]*undef *)

type escape_sequence = Token.t

type pat_b56baf5 = Token.t (* pattern #[ 	]*region *)

type pat_3df6e71 = Token.t (* pattern #[ 	]*if *)

type optional_semi = Token.t

type verbatim_string_literal = Token.t

type interpolation_open_brace = Token.t

type interpolation_string_content = Token.t

type modifier = [
    `Abst of Token.t (* "abstract" *)
  | `Async of Token.t (* "async" *)
  | `Const of Token.t (* "const" *)
  | `Extern of Token.t (* "extern" *)
  | `File of Token.t (* "file" *)
  | `Fixed of Token.t (* "fixed" *)
  | `Inte of Token.t (* "internal" *)
  | `New of Token.t (* "new" *)
  | `Over of Token.t (* "override" *)
  | `Part of Token.t (* "partial" *)
  | `Priv of Token.t (* "private" *)
  | `Prot of Token.t (* "protected" *)
  | `Public of Token.t (* "public" *)
  | `Read of Token.t (* "readonly" *)
  | `Requ of Token.t (* "required" *)
  | `Sealed of Token.t (* "sealed" *)
  | `Static of Token.t (* "static" *)
  | `Unsafe of Token.t (* "unsafe" *)
  | `Virt of Token.t (* "virtual" *)
  | `Vola of Token.t (* "volatile" *)
]

type boolean_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]

type pat_1d78758 = Token.t (* pattern \n *)

type semgrep_metavariable = Token.t

type anon_choice_ref_eec35e8 = [
    `Ref of Token.t (* "ref" *)
  | `Out of Token.t (* "out" *)
  | `In of Token.t (* "in" *)
]

type string_literal_encoding = Token.t (* pattern (u|U)8 *)

type interpolation_regular_start = Token.t

type integer_literal = Token.t

type anon_choice_DOT_2ad1dab = [
    `DOT of Token.t (* "." *)
  | `DASHGT of Token.t (* "->" *)
]

type interpolation_format_clause = (Token.t (* ":" *) * pat_52ffbd7)

type string_literal_content = [
    `Imm_tok_prec_p1_pat_5a6fa79 of imm_tok_prec_p1_pat_5a6fa79
  | `Imm_tok_bslash_pat_422e99f of imm_tok_bslash_pat_422e99f
]

type character_literal = (
    Token.t (* "'" *)
  * [
        `Char_lit_content of character_literal_content (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
    ]
  * Token.t (* "'" *)
)

type identifier = [
    `Choice_id_tok of [
        `Id_tok of identifier_token (*tok*)
      | `Rese_id of reserved_identifier
    ]
  | `Semg_meta of semgrep_metavariable (*tok*)
]

type string_literal = (
    Token.t (* "\"" *)
  * [
        `Str_lit_content of string_literal_content
      | `Esc_seq of escape_sequence (*tok*)
    ]
      list (* zero or more *)
  * Token.t (* "\"" *)
  * string_literal_encoding (*tok*) option
)

type variable_designation = [
    `Disc of Token.t (* "_" *)
  | `Paren_var_desi of (
        Token.t (* "(" *)
      * (
            variable_designation
          * (Token.t (* "," *) * variable_designation)
              list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
    )
  | `Id of identifier
]

type anon_choice_Cdecl_63b6085 = [
    `Cdecl of Token.t (* "Cdecl" *)
  | `Stdc of Token.t (* "Stdcall" *)
  | `This of Token.t (* "Thiscall" *)
  | `Fast of Token.t (* "Fastcall" *)
  | `Id of identifier
]

type anon_choice_id_f2cdd14 = [
    `Id of identifier
  | `Int_lit of integer_literal (*tok*)
]

type anon_choice_id_c036834 = [
    `Id of identifier
  | `Disc of Token.t (* "_" *)
  | `Tuple_pat of tuple_pattern
]

and tuple_pattern = (
    Token.t (* "(" *)
  * anon_choice_id_c036834
  * (Token.t (* "," *) * anon_choice_id_c036834) list (* zero or more *)
  * Token.t (* ")" *)
)

type preproc_binary_expression = [
    `Prep_exp_BARBAR_prep_exp of (
        preproc_expression * Token.t (* "||" *) * preproc_expression
    )
  | `Prep_exp_AMPAMP_prep_exp of (
        preproc_expression * Token.t (* "&&" *) * preproc_expression
    )
  | `Prep_exp_EQEQ_prep_exp of (
        preproc_expression * Token.t (* "==" *) * preproc_expression
    )
  | `Prep_exp_BANGEQ_prep_exp of (
        preproc_expression * Token.t (* "!=" *) * preproc_expression
    )
]

and preproc_expression = [
    `Id of identifier
  | `Bool_lit of boolean_literal
  | `Int_lit of integer_literal (*tok*)
  | `Char_lit of character_literal
  | `Prep_un_exp of (Token.t (* "!" *) * preproc_expression)
  | `Prep_bin_exp of preproc_binary_expression
  | `Prep_paren_exp of (
        Token.t (* "(" *) * preproc_expression * Token.t (* ")" *)
    )
]

type join_into_clause = (Token.t (* "into" *) * identifier)

type literal = [
    `Null_lit of Token.t (* "null" *)
  | `Char_lit of character_literal
  | `Int_lit of integer_literal (*tok*)
  | `Real_lit of real_literal (*tok*)
  | `Bool_lit of boolean_literal
  | `Str_lit of string_literal
  | `Verb_str_lit of verbatim_string_literal (*tok*)
  | `Raw_str_lit of (
        raw_string_start (*tok*)
      * raw_string_content (*tok*)
      * raw_string_end (*tok*)
      * pat_c1fe926 option
    )
]

type calling_convention = [
    `Mana of Token.t (* "managed" *)
  | `Unma_opt_LBRACK_choice_Cdecl_rep_COMMA_choice_Cdecl_RBRACK of (
        Token.t (* "unmanaged" *)
      * (
            Token.t (* "[" *)
          * anon_choice_Cdecl_63b6085
          * (Token.t (* "," *) * anon_choice_Cdecl_63b6085)
              list (* zero or more *)
          * Token.t (* "]" *)
        )
          option
    )
]

type anon_choice_id_bf14316 = [
    `Id of identifier
  | `Tuple_pat of tuple_pattern
]

type accessor_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * [
        `Get of Token.t (* "get" *)
      | `Set of Token.t (* "set" *)
      | `Add of Token.t (* "add" *)
      | `Remove of Token.t (* "remove" *)
      | `Init of Token.t (* "init" *)
      | `Id of identifier
    ]
  * function_body
)

and accessor_list = (
    Token.t (* "{" *)
  * accessor_declaration list (* zero or more *)
  * Token.t (* "}" *)
)

and anon_choice_enum_member_decl_fe2c440 = [
    `Enum_member_decl of enum_member_declaration
  | `Prep_if_in_enum_member_decl of (
        pat_3df6e71
      * preproc_expression
      * pat_1d78758
      * enum_member_declaration option
      * anon_choice_prep_else_in_enum_member_decl_ef97f12 option
      * pat_c46d1b2
    )
]

and anon_choice_exp_3bb8381 = [
    `Exp of expression
  | `Pred_type of predefined_type (*tok*)
  | `Name of name
]

and anon_choice_param_ce11a32 = [
    `Param of parameter
  | `Param_array of (
        attribute_list list (* zero or more *)
      * Token.t (* "params" *)
      * [ `Array_type of array_type | `Null_type of nullable_type ]
      * identifier
    )
]

and anon_choice_param_rep_COMMA_choice_param_6325c4d = (
    anon_choice_param_ce11a32
  * (Token.t (* "," *) * anon_choice_param_ce11a32) list (* zero or more *)
)

and anon_choice_pat_9cb1b05 = [
    `Pat of pattern
  | `DOTDOT of Token.t (* ".." *)
]

and anon_choice_prep_else_8b52b0f = [
    `Prep_else of (pat_56631e5 * declaration list (* zero or more *))
  | `Prep_elif of (
        pat_bfeb4bb
      * preproc_expression
      * pat_1d78758
      * declaration list (* zero or more *)
      * anon_choice_prep_else_8b52b0f option
    )
]

and anon_choice_prep_else_in_enum_member_decl_ef97f12 = [
    `Prep_else_in_enum_member_decl of (
        pat_56631e5
      * enum_member_declaration option
    )
  | `Prep_elif_in_enum_member_decl of (
        pat_bfeb4bb
      * preproc_expression
      * pat_1d78758
      * enum_member_declaration option
      * anon_choice_prep_else_in_enum_member_decl_ef97f12 option
    )
]

and anon_choice_prep_else_in_exp_678167b = [
    `Prep_else_in_exp of (pat_56631e5 * expression option)
  | `Prep_elif_in_exp of (
        pat_bfeb4bb
      * preproc_expression
      * pat_1d78758
      * expression option
      * anon_choice_prep_else_in_exp_678167b option
    )
]

and anon_choice_prep_else_in_top_level_0825411 = [
    `Prep_else_in_top_level of (
        pat_56631e5
      * anon_choice_top_level_item_no_stmt_65e2afd list (* zero or more *)
    )
  | `Prep_elif_in_top_level of (
        pat_bfeb4bb
      * preproc_expression
      * pat_1d78758
      * anon_choice_top_level_item_no_stmt_65e2afd list (* zero or more *)
      * anon_choice_prep_else_in_top_level_0825411 option
    )
]

and anon_choice_top_level_item_no_stmt_65e2afd = [
    `Choice_extern_alias_dire of top_level_item_no_statement
  | `Stmt of global_statement
]

and anon_opt_exp_rep_interp_alig_clause_cd88eaa =
  (expression * interpolation_alignment_clause list (* zero or more *))
    option

and anonymous_object_member_declarator = [
    `Id_EQ_exp of with_initializer
  | `Exp of expression
]

and argument = [
    `Opt_id_COLON_opt_choice_ref_choice_exp of (
        (identifier * Token.t (* ":" *)) option
      * anon_choice_ref_eec35e8 option
      * [ `Exp of expression | `Decl_exp of declaration_expression ]
    )
  | `Semg_vari_meta of semgrep_variadic_metavariable (*tok*)
]

and argument_list = (
    Token.t (* "(" *)
  * (argument * (Token.t (* "," *) * argument) list (* zero or more *))
      option
  * Token.t (* ")" *)
)

and array_base_type = [
    `Array_type of array_type
  | `Name of name
  | `Null_type of nullable_type
  | `Poin_type of pointer_type
  | `Func_poin_type of function_pointer_type
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of tuple_type
]

and array_rank_specifier = (
    Token.t (* "[" *)
  * (
        expression option
      * (Token.t (* "," *) * expression option) list (* zero or more *)
    )
      option
  * Token.t (* "]" *)
)

and array_type = (array_base_type * array_rank_specifier)

and arrow_expression_clause = (Token.t (* "=>" *) * expression)

and attribute = (name * attribute_argument_list option)

and attribute_argument = (
    (identifier * [ `COLON of Token.t (* ":" *) | `EQ of Token.t (* "=" *) ])
      option
  * expression
)

and attribute_argument_list = (
    Token.t (* "(" *)
  * (
        attribute_argument
      * (Token.t (* "," *) * attribute_argument) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and attribute_list = (
    Token.t (* "[" *)
  * attribute_target_specifier option
  * attribute
  * (Token.t (* "," *) * attribute) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

and base_list = (
    Token.t (* ":" *)
  * type_pattern
  * argument_list option
  * (Token.t (* "," *) * type_pattern * argument_list option)
      list (* zero or more *)
)

and binary_expression = [
    `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Exp_GTGTGT_exp of (expression * Token.t (* ">>>" *) * expression)
  | `Exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
  | `Exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Exp_GT_exp of (expression * Token.t (* ">" *) * expression)
  | `Exp_QMARKQMARK_exp of (expression * Token.t (* "??" *) * expression)
]

and block = (
    Token.t (* "{" *)
  * global_statement list (* zero or more *)
  * Token.t (* "}" *)
)

and bracketed_argument_list = (
    Token.t (* "[" *)
  * argument
  * (Token.t (* "," *) * argument) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

and bracketed_parameter_list = (
    Token.t (* "[" *)
  * anon_choice_param_rep_COMMA_choice_param_6325c4d option
  * Token.t (* "]" *)
)

and cast_expression = (
    Token.t (* "(" *) * type_pattern * Token.t (* ")" *) * expression
)

and catch_clause = (
    Token.t (* "catch" *)
  * catch_declaration option
  * catch_filter_clause option
  * block
)

and catch_declaration = (
    Token.t (* "(" *)
  * type_pattern
  * identifier option
  * Token.t (* ")" *)
)

and catch_filter_clause = (
    Token.t (* "when" *) * Token.t (* "(" *) * expression * Token.t (* ")" *)
)

and class_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "class" *)
  * identifier
  * type_parameter_list option
  * parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * optional_semi (*tok*)
)

and constant_pattern = [
    `Bin_exp of binary_expression
  | `Defa_exp of default_expression
  | `Inte_str_exp of interpolated_string_expression
  | `Paren_exp of parenthesized_expression
  | `Post_un_exp of postfix_unary_expression
  | `Prefix_un_exp of prefix_unary_expression
  | `Sizeof_exp of sizeof_expression
  | `Tuple_exp of tuple_expression
  | `Typeof_exp of typeof_expression
  | `Member_access_exp of member_access_expression
  | `Invo_exp of invocation_expression
  | `Cast_exp of cast_expression
  | `Simple_name of simple_name
  | `Lit of literal
]

and constructor_initializer = (
    Token.t (* ":" *)
  * [ `Base of Token.t (* "base" *) | `This of Token.t (* "this" *) ]
  * argument_list
)

and declaration = [
    `Class_decl of class_declaration
  | `Struct_decl of struct_declaration
  | `Enum_decl of enum_declaration
  | `Dele_decl of delegate_declaration
  | `Field_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Meth_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * explicit_interface_specifier option
      * identifier
      * type_parameter_list option
      * parameter_list
      * type_parameter_constraints_clause list (* zero or more *)
      * function_body
    )
  | `Event_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "event" *)
      * type_pattern
      * explicit_interface_specifier option
      * identifier
      * [ `Acce_list of accessor_list | `SEMI of Token.t (* ";" *) ]
    )
  | `Event_field_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "event" *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Record_decl of record_declaration
  | `Cons_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * identifier
      * parameter_list
      * constructor_initializer option
      * function_body
    )
  | `Dest_decl of (
        attribute_list list (* zero or more *)
      * Token.t (* "extern" *) option
      * Token.t (* "~" *)
      * identifier
      * parameter_list
      * function_body
    )
  | `Inde_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * explicit_interface_specifier option
      * Token.t (* "this" *)
      * bracketed_parameter_list
      * [
            `Acce_list of accessor_list
          | `Arrow_exp_clause_SEMI of (
                arrow_expression_clause * Token.t (* ";" *)
            )
        ]
    )
  | `Inte_decl of interface_declaration
  | `Name_decl of namespace_declaration
  | `Op_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * explicit_interface_specifier option
      * Token.t (* "operator" *)
      * Token.t (* "checked" *) option
      * [
            `BANG of Token.t (* "!" *)
          | `TILDE of Token.t (* "~" *)
          | `PLUSPLUS of Token.t (* "++" *)
          | `DASHDASH of Token.t (* "--" *)
          | `True of Token.t (* "true" *)
          | `False of Token.t (* "false" *)
          | `PLUS of Token.t (* "+" *)
          | `DASH of Token.t (* "-" *)
          | `STAR of Token.t (* "*" *)
          | `SLASH of Token.t (* "/" *)
          | `PERC of Token.t (* "%" *)
          | `HAT of Token.t (* "^" *)
          | `BAR of Token.t (* "|" *)
          | `AMP of Token.t (* "&" *)
          | `LTLT of Token.t (* "<<" *)
          | `GTGT of Token.t (* ">>" *)
          | `GTGTGT of Token.t (* ">>>" *)
          | `EQEQ of Token.t (* "==" *)
          | `BANGEQ of Token.t (* "!=" *)
          | `GT of Token.t (* ">" *)
          | `LT of Token.t (* "<" *)
          | `GTEQ of Token.t (* ">=" *)
          | `LTEQ of Token.t (* "<=" *)
        ]
      * parameter_list
      * function_body
    )
  | `Conv_op_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * [
            `Impl of Token.t (* "implicit" *)
          | `Expl of Token.t (* "explicit" *)
        ]
      * explicit_interface_specifier option
      * Token.t (* "operator" *)
      * Token.t (* "checked" *) option
      * type_pattern
      * parameter_list
      * function_body
    )
  | `Prop_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * explicit_interface_specifier option
      * identifier
      * [
            `Acce_list_opt_EQ_exp_SEMI of (
                accessor_list
              * (Token.t (* "=" *) * expression * Token.t (* ";" *)) option
            )
          | `Arrow_exp_clause_SEMI of (
                arrow_expression_clause * Token.t (* ";" *)
            )
        ]
    )
  | `Using_dire of using_directive
  | `Prep_if of (
        pat_3df6e71
      * preproc_expression
      * pat_1d78758
      * declaration list (* zero or more *)
      * anon_choice_prep_else_8b52b0f option
      * pat_c46d1b2
    )
  | `Ellips of Token.t (* "..." *)
]

and declaration_expression = (type_pattern * identifier)

and declaration_list = (
    Token.t (* "{" *)
  * declaration list (* zero or more *)
  * Token.t (* "}" *)
)

and deep_ellipsis = (
    Token.t (* "<..." *) * expression * Token.t (* "...>" *)
)

and default_expression = (
    Token.t (* "default" *)
  * (Token.t (* "(" *) * type_pattern * Token.t (* ")" *)) option
)

and delegate_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "delegate" *)
  * type_pattern
  * identifier
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * Token.t (* ";" *)
)

and enum_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "enum" *)
  * identifier
  * base_list option
  * enum_member_declaration_list
  * optional_semi (*tok*)
)

and enum_member_declaration = [
    `Rep_attr_list_id_opt_EQ_exp of (
        attribute_list list (* zero or more *)
      * identifier
      * (Token.t (* "=" *) * expression) option
    )
  | `Ellips of Token.t (* "..." *)
]

and enum_member_declaration_list = (
    Token.t (* "{" *)
  * (
        anon_choice_enum_member_decl_fe2c440
      * (Token.t (* "," *) * anon_choice_enum_member_decl_fe2c440)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and explicit_interface_specifier = (name * Token.t (* "." *))

and expression = [
    `Non_lvalue_exp of non_lvalue_expression
  | `Lvalue_exp of lvalue_expression
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips of deep_ellipsis
  | `Member_access_ellips_exp of member_access_ellipsis_expression
  | `Typed_meta of typed_metavariable
]

and expression_statement = [
    `Exp_stmt_exp_SEMI of (
        expression_statement_expression * Token.t (* ";" *)
    )
  | `Ellips_SEMI of (Token.t (* "..." *) * Token.t (* ";" *))
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips_SEMI of (deep_ellipsis * Token.t (* ";" *))
  | `Member_access_ellips_exp_SEMI of (
        member_access_ellipsis_expression * Token.t (* ";" *)
    )
  | `Semg_meta_SEMI of (semgrep_metavariable (*tok*) * Token.t (* ";" *))
  | `Typed_meta_SEMI of (typed_metavariable * Token.t (* ";" *))
]

and expression_statement_expression = [
    `Assign_exp of (
        lvalue_expression
      * [
            `EQ of Token.t (* "=" *)
          | `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
          | `GTGTGTEQ of Token.t (* ">>>=" *)
          | `QMARKQMARKEQ of Token.t (* "??=" *)
        ]
      * expression
    )
  | `Invo_exp of invocation_expression
  | `Post_un_exp of postfix_unary_expression
  | `Prefix_un_exp of prefix_unary_expression
  | `Await_exp of (Token.t (* "await" *) * expression)
  | `Obj_crea_exp of (
        Token.t (* "new" *)
      * type_pattern
      * argument_list option
      * initializer_expression option
    )
  | `Paren_exp of parenthesized_expression
]

and finally_clause = (Token.t (* "finally" *) * block)

and from_clause = (
    Token.t (* "from" *)
  * type_pattern option
  * identifier
  * Token.t (* "in" *)
  * expression
)

and function_body = [
    `Blk of block
  | `Arrow_exp_clause_SEMI of (arrow_expression_clause * Token.t (* ";" *))
  | `SEMI of Token.t (* ";" *)
]

and function_pointer_parameter = (
    anon_choice_ref_eec35e8 option
  * ref_base_type
)

and function_pointer_type = (
    Token.t (* "delegate" *)
  * Token.t (* "*" *)
  * calling_convention option
  * Token.t (* "<" *)
  * (function_pointer_parameter * Token.t (* "," *)) list (* zero or more *)
  * type_pattern
  * Token.t (* ">" *)
)

and global_statement = statement

and initializer_expression = (
    Token.t (* "{" *)
  * anon_opt_exp_rep_interp_alig_clause_cd88eaa
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and interface_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "interface" *)
  * identifier
  * type_parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * optional_semi (*tok*)
)

and interpolated_raw_string_content = [
    `Interp_str_content of interpolation_string_content (*tok*)
  | `Interp of interpolation
]

and interpolated_string_content = [
    `Interp_str_content of interpolation_string_content (*tok*)
  | `Esc_seq of escape_sequence (*tok*)
  | `Interp of interpolation
]

and interpolated_string_expression = [
    `Interp_regu_start_interp_start_quote_rep_inte_str_content_interp_end_quote of (
        interpolation_regular_start (*tok*)
      * interpolation_start_quote (*tok*)
      * interpolated_string_content list (* zero or more *)
      * interpolation_end_quote (*tok*)
    )
  | `Interp_verb_start_interp_start_quote_rep_inte_verb_str_content_interp_end_quote of (
        interpolation_verbatim_start (*tok*)
      * interpolation_start_quote (*tok*)
      * interpolated_verbatim_string_content list (* zero or more *)
      * interpolation_end_quote (*tok*)
    )
  | `Interp_raw_start_interp_start_quote_rep_inte_raw_str_content_interp_end_quote of (
        interpolation_raw_start (*tok*)
      * interpolation_start_quote (*tok*)
      * interpolated_raw_string_content list (* zero or more *)
      * interpolation_end_quote (*tok*)
    )
]

and interpolated_verbatim_string_content = [
    `Interp_str_content of interpolation_string_content (*tok*)
  | `Interp of interpolation
]

and interpolation = (
    interpolation_open_brace (*tok*)
  * expression
  * interpolation_alignment_clause option
  * interpolation_format_clause option
  * interpolation_close_brace (*tok*)
)

and interpolation_alignment_clause = (Token.t (* "," *) * expression)

and invocation_expression = (expression * argument_list)

and join_body = (
    Token.t (* "on" *) * expression * Token.t (* "equals" *) * expression
)

and join_header = (
    type_pattern option
  * identifier
  * Token.t (* "in" *)
  * expression
)

and lambda_parameters = [ `Param_list of parameter_list | `Id of identifier ]

and lvalue_expression = [
    `This of Token.t (* "this" *)
  | `Member_access_exp of member_access_expression
  | `Tuple_exp of tuple_expression
  | `Simple_name of simple_name
  | `Elem_access_exp of (expression * bracketed_argument_list)
  | `Brac_arg_list of bracketed_argument_list
  | `Poin_indi_exp of (Token.t (* "*" *) * lvalue_expression)
  | `Paren_lvalue_exp of (
        Token.t (* "(" *) * lvalue_expression * Token.t (* ")" *)
    )
]

and member_access_ellipsis_expression = (
    anon_choice_exp_3bb8381 * anon_choice_DOT_2ad1dab * Token.t (* "..." *)
)

and member_access_expression = (
    anon_choice_exp_3bb8381 * anon_choice_DOT_2ad1dab * simple_name
)

and member_binding_expression = (Token.t (* "." *) * simple_name)

and name = [
    `Alias_qual_name of (identifier * Token.t (* "::" *) * simple_name)
  | `Qual_name of (name * Token.t (* "." *) * simple_name)
  | `Simple_name of simple_name
]

and namespace_declaration = (
    Token.t (* "namespace" *) * name * declaration_list
  * optional_semi (*tok*)
)

and namespace_member_declaration = [
    `Name_decl of namespace_declaration
  | `Type_decl of type_declaration
]

and non_lvalue_expression = [
    `Base of Token.t (* "base" *)
  | `Bin_exp of binary_expression
  | `Inte_str_exp of interpolated_string_expression
  | `Cond_exp of (
        expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
      * expression
    )
  | `Cond_access_exp of (
        expression
      * Token.t (* "?" *)
      * [
            `Member_bind_exp of member_binding_expression
          | `Brac_arg_list of bracketed_argument_list
        ]
    )
  | `Lit of literal
  | `Exp_stmt_exp of expression_statement_expression
  | `Is_exp of (expression * Token.t (* "is" *) * type_pattern)
  | `Is_pat_exp of (expression * Token.t (* "is" *) * pattern)
  | `As_exp of (expression * Token.t (* "as" *) * type_pattern)
  | `Cast_exp of cast_expression
  | `Chec_exp of (
        anon_choice_chec_7987657 * Token.t (* "(" *) * expression
      * Token.t (* ")" *)
    )
  | `Switch_exp of (
        expression
      * Token.t (* "switch" *)
      * Token.t (* "{" *)
      * (
            switch_expression_arm
          * (Token.t (* "," *) * switch_expression_arm)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Throw_exp of (Token.t (* "throw" *) * expression)
  | `Defa_exp of default_expression
  | `Lambda_exp of (
        attribute_list list (* zero or more *)
      * anon_choice_static_d4628a0 list (* zero or more *)
      * type_pattern option
      * lambda_parameters
      * Token.t (* "=>" *)
      * [ `Blk of block | `Exp of expression ]
    )
  | `With_exp of (
        expression
      * Token.t (* "with" *)
      * Token.t (* "{" *)
      * (
            with_initializer
          * (Token.t (* "," *) * with_initializer) list (* zero or more *)
        )
          option
      * Token.t (* "}" *)
    )
  | `Sizeof_exp of sizeof_expression
  | `Typeof_exp of typeof_expression
  | `Make_exp of (
        Token.t (* "__makeref" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *)
    )
  | `Ref_exp of (Token.t (* "ref" *) * expression)
  | `Reft_exp of (
        Token.t (* "__reftype" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *)
    )
  | `Refv_exp of (
        Token.t (* "__refvalue" *) * Token.t (* "(" *) * expression
      * Token.t (* "," *) * type_pattern * Token.t (* ")" *)
    )
  | `Stac_exp of (
        Token.t (* "stackalloc" *)
      * array_type
      * initializer_expression option
    )
  | `Range_exp of (
        expression option
      * Token.t (* ".." *)
      * expression option
    )
  | `Array_crea_exp of (
        Token.t (* "new" *)
      * array_type
      * initializer_expression option
    )
  | `Anon_meth_exp of (
        anon_choice_static_d4628a0 list (* zero or more *)
      * Token.t (* "delegate" *)
      * parameter_list option
      * block
    )
  | `Anon_obj_crea_exp of (
        Token.t (* "new" *)
      * Token.t (* "{" *)
      * (
            anonymous_object_member_declarator
          * (Token.t (* "," *) * anonymous_object_member_declarator)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Impl_array_crea_exp of (
        Token.t (* "new" *)
      * Token.t (* "[" *)
      * Token.t (* "," *) list (* zero or more *)
      * Token.t (* "]" *)
      * initializer_expression
    )
  | `Impl_obj_crea_exp of (
        Token.t (* "new" *)
      * argument_list
      * initializer_expression option
    )
  | `Impl_stac_exp of (
        Token.t (* "stackalloc" *) * Token.t (* "[" *) * Token.t (* "]" *)
      * initializer_expression
    )
  | `Init_exp of initializer_expression
  | `Query_exp of (from_clause * query_body)
  | `Prep_if_in_exp of (
        pat_3df6e71
      * preproc_expression
      * pat_1d78758
      * expression option
      * anon_choice_prep_else_in_exp_678167b option
      * pat_c46d1b2
    )
]

and nullable_base_type = [
    `Array_type of array_type
  | `Name of name
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of tuple_type
]

and nullable_type = (nullable_base_type * Token.t (* "?" *))

and ordering = (
    expression
  * [
        `Asce of Token.t (* "ascending" *)
      | `Desc of Token.t (* "descending" *)
    ]
      option
)

and parameter = [
    `Rep_attr_list_opt_rep_choice_this_type_id_opt_EQ_exp of (
        attribute_list list (* zero or more *)
      * parameter_type_with_modifiers option
      * identifier
      * (Token.t (* "=" *) * expression) option
    )
  | `Ellips of Token.t (* "..." *)
]

and parameter_list = (
    Token.t (* "(" *)
  * anon_choice_param_rep_COMMA_choice_param_6325c4d option
  * Token.t (* ")" *)
)

and parameter_type_with_modifiers = (
    [
        `This of Token.t (* "this" *)
      | `Scoped of Token.t (* "scoped" *)
      | `Ref of Token.t (* "ref" *)
      | `Out of Token.t (* "out" *)
      | `In of Token.t (* "in" *)
      | `Read of Token.t (* "readonly" *)
    ]
      list (* zero or more *)
  * type_pattern
)

and parenthesized_expression = (
    Token.t (* "(" *) * non_lvalue_expression * Token.t (* ")" *)
)

and pattern = [
    `Cst_pat of constant_pattern
  | `Decl_pat of (type_pattern * variable_designation)
  | `Disc of Token.t (* "_" *)
  | `Recu_pat of (
        type_pattern option
      * [
            `Posi_pat_clause_opt_prop_pat_clause of (
                positional_pattern_clause
              * property_pattern_clause option
            )
          | `Prop_pat_clause of property_pattern_clause
        ]
      * variable_designation option
    )
  | `Var_pat of (Token.t (* "var" *) * variable_designation)
  | `Nega_pat of (Token.t (* "not" *) * pattern)
  | `Paren_pat of (Token.t (* "(" *) * pattern * Token.t (* ")" *))
  | `Rela_pat of relational_pattern
  | `Or_pat of (pattern * Token.t (* "or" *) * pattern)
  | `And_pat of (pattern * Token.t (* "and" *) * pattern)
  | `List_pat of (
        Token.t (* "[" *)
      * (
            anon_choice_pat_9cb1b05
          * (Token.t (* "," *) * anon_choice_pat_9cb1b05)
              list (* zero or more *)
          * Token.t (* "," *) option
        )
          option
      * Token.t (* "]" *)
    )
  | `Type_pat of type_pattern
]

and pointer_base_type = [
    `Name of name
  | `Null_type of nullable_type
  | `Poin_type of pointer_type
  | `Func_poin_type of function_pointer_type
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of tuple_type
]

and pointer_type = (pointer_base_type * Token.t (* "*" *))

and positional_pattern_clause = (
    Token.t (* "(" *)
  * (subpattern * (Token.t (* "," *) * subpattern) list (* one or more *))
      option
  * Token.t (* ")" *)
)

and postfix_unary_expression = [
    `Exp_PLUSPLUS of (expression * Token.t (* "++" *))
  | `Exp_DASHDASH of (expression * Token.t (* "--" *))
  | `Exp_BANG of (expression * Token.t (* "!" *))
]

and prefix_unary_expression = (
    [
        `PLUSPLUS of Token.t (* "++" *)
      | `DASHDASH of Token.t (* "--" *)
      | `PLUS of Token.t (* "+" *)
      | `DASH of Token.t (* "-" *)
      | `BANG of Token.t (* "!" *)
      | `TILDE of Token.t (* "~" *)
      | `AMP of Token.t (* "&" *)
      | `HAT of Token.t (* "^" *)
    ]
  * expression
)

and preproc_if_in_top_level = (
    pat_3df6e71
  * preproc_expression
  * pat_1d78758
  * anon_choice_top_level_item_no_stmt_65e2afd list (* zero or more *)
  * anon_choice_prep_else_in_top_level_0825411 option
  * pat_c46d1b2
)

and primary_constructor_base_type = (name * argument_list)

and property_pattern_clause = (
    Token.t (* "{" *)
  * (subpattern * (Token.t (* "," *) * subpattern) list (* zero or more *))
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and query_body = (
    query_clause list (* zero or more *)
  * select_or_group_clause
  * (
        Token.t (* "into" *)
      * identifier
      * query_clause list (* zero or more *)
      * select_or_group_clause
    )
      list (* zero or more *)
)

and query_clause = [
    `From_clause of from_clause
  | `Join_clause of (
        Token.t (* "join" *)
      * join_header
      * join_body
      * join_into_clause option
    )
  | `Let_clause of (
        Token.t (* "let" *) * identifier * Token.t (* "=" *) * expression
    )
  | `Order_by_clause of (
        Token.t (* "orderby" *)
      * ordering
      * (Token.t (* "," *) * ordering) list (* zero or more *)
    )
  | `Where_clause of (Token.t (* "where" *) * expression)
]

and record_base = [
    `COLON_name_rep_COMMA_name of (
        Token.t (* ":" *)
      * name
      * (Token.t (* "," *) * name) list (* zero or more *)
    )
  | `COLON_prim_cons_base_type_opt_COMMA_name_rep_COMMA_name of (
        Token.t (* ":" *)
      * primary_constructor_base_type
      * (
            Token.t (* "," *)
          * name
          * (Token.t (* "," *) * name) list (* zero or more *)
        )
          option
    )
]

and record_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "record" *)
  * [ `Class of Token.t (* "class" *) | `Struct of Token.t (* "struct" *) ]
      option
  * identifier
  * type_parameter_list option
  * parameter_list option
  * record_base option
  * type_parameter_constraints_clause list (* zero or more *)
  * [ `Decl_list of declaration_list | `SEMI of Token.t (* ";" *) ]
  * optional_semi (*tok*)
)

and ref_base_type = [
    `Impl_type of Token.t (* "var" *)
  | `Name of name
  | `Null_type of nullable_type
  | `Array_type of array_type
  | `Poin_type of pointer_type
  | `Func_poin_type of function_pointer_type
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of tuple_type
]

and ref_type = (
    Token.t (* "ref" *)
  * Token.t (* "readonly" *) option
  * type_pattern
)

and relational_pattern = [
    `LT_exp of (Token.t (* "<" *) * expression)
  | `LTEQ_exp of (Token.t (* "<=" *) * expression)
  | `GT_exp of (Token.t (* ">" *) * expression)
  | `GTEQ_exp of (Token.t (* ">=" *) * expression)
]

and scoped_base_type = [ `Name of name | `Ref_type of ref_type ]

and select_or_group_clause = [
    `Group_clause of (
        Token.t (* "group" *) * expression * Token.t (* "by" *) * expression
    )
  | `Select_clause of (Token.t (* "select" *) * expression)
]

and simple_name = [
    `Id of identifier
  | `Gene_name of (identifier * type_argument_list)
]

and sizeof_expression = (
    Token.t (* "sizeof" *) * Token.t (* "(" *) * type_pattern
  * Token.t (* ")" *)
)

and statement = [
    `Blk of block
  | `Brk_stmt of (Token.t (* "break" *) * Token.t (* ";" *))
  | `Chec_stmt of (anon_choice_chec_7987657 * block)
  | `Cont_stmt of (Token.t (* "continue" *) * Token.t (* ";" *))
  | `Do_stmt of (
        Token.t (* "do" *) * global_statement * Token.t (* "while" *)
      * Token.t (* "(" *) * expression * Token.t (* ")" *)
      * Token.t (* ";" *)
    )
  | `Empty_stmt of Token.t (* ";" *)
  | `Exp_stmt of expression_statement
  | `Fixed_stmt of (
        Token.t (* "fixed" *) * Token.t (* "(" *) * variable_declaration
      * Token.t (* ")" *) * global_statement
    )
  | `For_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * [
            `Var_decl of variable_declaration
          | `Exp_rep_COMMA_exp of (
                expression
              * interpolation_alignment_clause list (* zero or more *)
            )
        ]
          option
      * Token.t (* ";" *)
      * expression option
      * Token.t (* ";" *)
      * anon_opt_exp_rep_interp_alig_clause_cd88eaa
      * Token.t (* ")" *)
      * global_statement
    )
  | `Ret_stmt of (
        Token.t (* "return" *)
      * expression option
      * Token.t (* ";" *)
    )
  | `Lock_stmt of (
        Token.t (* "lock" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *) * global_statement
    )
  | `Yield_stmt of (
        Token.t (* "yield" *)
      * [
            `Ret_exp of (Token.t (* "return" *) * expression)
          | `Brk of Token.t (* "break" *)
        ]
      * Token.t (* ";" *)
    )
  | `Switch_stmt of (
        Token.t (* "switch" *)
      * [
            `LPAR_exp_RPAR of (
                Token.t (* "(" *) * expression * Token.t (* ")" *)
            )
          | `Tuple_exp of tuple_expression
        ]
      * switch_body
    )
  | `Throw_stmt of (
        Token.t (* "throw" *)
      * expression option
      * Token.t (* ";" *)
    )
  | `Try_stmt of (
        Token.t (* "try" *)
      * block
      * catch_clause list (* zero or more *)
      * finally_clause option
    )
  | `Unsafe_stmt of (Token.t (* "unsafe" *) * block)
  | `Using_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "using" *)
      * Token.t (* "(" *)
      * [
            `Using_var_decl of using_variable_declaration
          | `Exp of expression
        ]
      * Token.t (* ")" *)
      * global_statement
    )
  | `Fore_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "foreach" *)
      * Token.t (* "(" *)
      * [
            `Type_choice_id of (type_pattern * anon_choice_id_bf14316)
          | `Exp of expression
        ]
      * Token.t (* "in" *)
      * expression
      * Token.t (* ")" *)
      * global_statement
    )
  | `Goto_stmt of (
        Token.t (* "goto" *)
      * [ `Case of Token.t (* "case" *) | `Defa of Token.t (* "default" *) ]
          option
      * expression option
      * Token.t (* ";" *)
    )
  | `Labe_stmt of (identifier * Token.t (* ":" *) * global_statement)
  | `If_stmt of (
        Token.t (* "if" *)
      * Token.t (* "(" *)
      * expression
      * Token.t (* ")" *)
      * global_statement
      * (Token.t (* "else" *) * global_statement) option
    )
  | `While_stmt of (
        Token.t (* "while" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *) * global_statement
    )
  | `Local_decl_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "using" *) option
      * modifier list (* zero or more *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Local_func_stmt of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * identifier
      * type_parameter_list option
      * parameter_list
      * type_parameter_constraints_clause list (* zero or more *)
      * function_body
    )
  | `Prep_if_in_top_level of preproc_if_in_top_level
]

and struct_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "ref" *) option
  * Token.t (* "struct" *)
  * identifier
  * type_parameter_list option
  * parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * optional_semi (*tok*)
)

and subpattern = ((expression * Token.t (* ":" *)) option * pattern)

and switch_body = (
    Token.t (* "{" *)
  * switch_section list (* zero or more *)
  * Token.t (* "}" *)
)

and switch_expression_arm = (
    pattern
  * when_clause option
  * Token.t (* "=>" *)
  * expression
)

and switch_section = (
    [
        `Case_choice_exp of (
            Token.t (* "case" *)
          * [
                `Exp of expression
              | `Pat_opt_when_clause of (pattern * when_clause option)
            ]
        )
      | `Defa of Token.t (* "default" *)
    ]
  * Token.t (* ":" *)
  * global_statement list (* zero or more *)
)

and top_level_item_no_statement = [
    `Extern_alias_dire of (
        Token.t (* "extern" *) * Token.t (* "alias" *) * identifier
      * Token.t (* ";" *)
    )
  | `Using_dire of using_directive
  | `Global_attr of (
        Token.t (* "[" *)
      * [
            `Asse of Token.t (* "assembly" *)
          | `Module of Token.t (* "module" *)
        ]
      * Token.t (* ":" *)
      * attribute
      * (Token.t (* "," *) * attribute) list (* zero or more *)
      * Token.t (* "," *) option
      * Token.t (* "]" *)
    )
  | `Prep_if_in_top_level of preproc_if_in_top_level
  | `Choice_name_decl of namespace_member_declaration
  | `File_scoped_name_decl of (
        global_statement list (* zero or more *)
      * namespace_member_declaration list (* zero or more *)
      * Token.t (* "namespace" *)
      * name
      * Token.t (* ";" *)
    )
]

and tuple_element = (type_pattern * identifier option)

and tuple_expression = (
    Token.t (* "(" *)
  * argument
  * (Token.t (* "," *) * argument) list (* one or more *)
  * Token.t (* ")" *)
)

and tuple_type = (
    Token.t (* "(" *)
  * tuple_element
  * (Token.t (* "," *) * tuple_element) list (* one or more *)
  * Token.t (* ")" *)
)

and type_ = [
    `Impl_type of Token.t (* "var" *)
  | `Array_type of array_type
  | `Name of name
  | `Null_type of nullable_type
  | `Poin_type of pointer_type
  | `Func_poin_type of function_pointer_type
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of tuple_type
  | `Ref_type of ref_type
  | `Scoped_type of (Token.t (* "scoped" *) * scoped_base_type)
]

and type_argument_list = (
    Token.t (* "<" *)
  * [
        `Rep_COMMA of Token.t (* "," *) list (* zero or more *)
      | `Type_rep_COMMA_type of (
            type_pattern
          * (Token.t (* "," *) * type_pattern) list (* zero or more *)
        )
    ]
  * Token.t (* ">" *)
)

and type_declaration = [
    `Class_decl of class_declaration
  | `Struct_decl of struct_declaration
  | `Enum_decl of enum_declaration
  | `Inte_decl of interface_declaration
  | `Dele_decl of delegate_declaration
  | `Record_decl of record_declaration
  | `Ellips of Token.t (* "..." *)
]

and type_parameter = (
    attribute_list list (* zero or more *)
  * [ `In of Token.t (* "in" *) | `Out of Token.t (* "out" *) ] option
  * identifier
)

and type_parameter_constraint = [
    `Class_opt_QMARK of (Token.t (* "class" *) * Token.t (* "?" *) option)
  | `Struct of Token.t (* "struct" *)
  | `Notn of Token.t (* "notnull" *)
  | `Unma of Token.t (* "unmanaged" *)
  | `Cons_cons of (
        Token.t (* "new" *) * Token.t (* "(" *) * Token.t (* ")" *)
    )
  | `Type of type_pattern
]

and type_parameter_constraints_clause = (
    Token.t (* "where" *)
  * identifier
  * Token.t (* ":" *)
  * type_parameter_constraint
  * (Token.t (* "," *) * type_parameter_constraint) list (* zero or more *)
)

and type_parameter_list = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* ">" *)
)

and type_pattern = type_

and typed_metavariable = (
    Token.t (* "(" *) * type_pattern * semgrep_metavariable (*tok*)
  * Token.t (* ")" *)
)

and typeof_expression = (
    Token.t (* "typeof" *) * Token.t (* "(" *) * type_pattern
  * Token.t (* ")" *)
)

and using_directive = (
    Token.t (* "global" *) option
  * Token.t (* "using" *)
  * [
        `Opt_unsafe_id_EQ_type of (
            Token.t (* "unsafe" *) option
          * identifier
          * Token.t (* "=" *)
          * type_pattern
        )
      | `Opt_static_opt_unsafe_name of (
            Token.t (* "static" *) option
          * Token.t (* "unsafe" *) option
          * name
        )
    ]
  * Token.t (* ";" *)
)

and using_variable_declaration = (
    type_pattern
  * using_variable_declarator
  * (Token.t (* "," *) * using_variable_declarator) list (* zero or more *)
)

and using_variable_declarator = (
    identifier
  * (Token.t (* "=" *) * expression) option
)

and variable_declaration = (
    type_pattern
  * variable_declarator
  * (Token.t (* "," *) * variable_declarator) list (* zero or more *)
)

and variable_declarator = (
    anon_choice_id_bf14316
  * bracketed_argument_list option
  * (Token.t (* "=" *) * expression) option
)

and when_clause = (Token.t (* "when" *) * expression)

and with_initializer = (identifier * Token.t (* "=" *) * expression)

type top_level_item = [
    `Choice_extern_alias_dire of top_level_item_no_statement
  | `Global_stmt of global_statement
]

type compilation_unit = [
    `Opt_sheb_dire_rep_top_level_item of (
        shebang_directive (*tok*) option
      * top_level_item list (* zero or more *)
    )
  | `Semg_exp of (Token.t (* "__SEMGREP_EXPRESSION" *) * expression)
]

type continue_statement (* inlined *) = (
    Token.t (* "continue" *) * Token.t (* ";" *)
)

type comment (* inlined *) = Token.t

type empty_statement (* inlined *) = Token.t (* ";" *)

type break_statement (* inlined *) = (
    Token.t (* "break" *) * Token.t (* ";" *)
)

type discard (* inlined *) = Token.t (* "_" *)

type constructor_constraint (* inlined *) = (
    Token.t (* "new" *) * Token.t (* "(" *) * Token.t (* ")" *)
)

type implicit_type (* inlined *) = Token.t (* "var" *)

type null_literal (* inlined *) = Token.t (* "null" *)

type preproc_directive (* inlined *) =
  Token.t (* pattern #[ \t]*[a-zA-Z0-9]\w* *)

type ellipsis (* inlined *) = Token.t (* "..." *)

type raw_string_literal (* inlined *) = (
    raw_string_start (*tok*)
  * raw_string_content (*tok*)
  * raw_string_end (*tok*)
  * pat_c1fe926 option
)

type preproc_nullable (* inlined *) = (
    pat_fdf8f81
  * [
        `Enable of Token.t (* "enable" *)
      | `Disa of Token.t (* "disable" *)
      | `Rest of Token.t (* "restore" *)
    ]
  * [
        `Annots of Token.t (* "annotations" *)
      | `Warnis of Token.t (* "warnings" *)
    ]
      option
  * pat_1d78758
)

type preproc_error (* inlined *) = (
    pat_8a5c9c8 * preproc_arg (*tok*) * pat_1d78758
)

type preproc_endregion (* inlined *) = (
    pat_721a115
  * preproc_arg (*tok*) option
  * pat_1d78758
)

type preproc_warning (* inlined *) = (
    pat_ca788a8 * preproc_arg (*tok*) * pat_1d78758
)

type preproc_define (* inlined *) = (
    pat_c3ea183 * preproc_arg (*tok*) * pat_1d78758
)

type preproc_undef (* inlined *) = (
    pat_4946ad9 * preproc_arg (*tok*) * pat_1d78758
)

type preproc_region (* inlined *) = (
    pat_b56baf5
  * preproc_arg (*tok*) option
  * pat_1d78758
)

type parenthesized_variable_designation (* inlined *) = (
    Token.t (* "(" *)
  * (
        variable_designation
      * (Token.t (* "," *) * variable_designation) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

type extern_alias_directive (* inlined *) = (
    Token.t (* "extern" *) * Token.t (* "alias" *) * identifier
  * Token.t (* ";" *)
)

type qualified_identifier (* inlined *) = (
    identifier
  * (Token.t (* "." *) * identifier) list (* zero or more *)
)

type preproc_parenthesized_expression (* inlined *) = (
    Token.t (* "(" *) * preproc_expression * Token.t (* ")" *)
)

type preproc_unary_expression (* inlined *) = (
    Token.t (* "!" *) * preproc_expression
)

type preproc_line (* inlined *) = (
    pat_d299690
  * [
        `Defa of Token.t (* "default" *)
      | `Hidden of Token.t (* "hidden" *)
      | `Int_lit_opt_str_lit of (
            integer_literal (*tok*)
          * string_literal option
        )
      | `LPAR_int_lit_COMMA_int_lit_RPAR_DASH_LPAR_int_lit_COMMA_int_lit_RPAR_opt_int_lit_str_lit of (
            Token.t (* "(" *)
          * integer_literal (*tok*)
          * Token.t (* "," *)
          * integer_literal (*tok*)
          * Token.t (* ")" *)
          * Token.t (* "-" *)
          * Token.t (* "(" *)
          * integer_literal (*tok*)
          * Token.t (* "," *)
          * integer_literal (*tok*)
          * Token.t (* ")" *)
          * integer_literal (*tok*) option
          * string_literal
        )
    ]
  * pat_1d78758
)

type var_pattern (* inlined *) = (Token.t (* "var" *) * variable_designation)

type preproc_pragma (* inlined *) = (
    pat_eb92600
  * [
        `Warn_choice_disa_opt_choice_id_rep_COMMA_choice_id of (
            Token.t (* "warning" *)
          * [
                `Disa of Token.t (* "disable" *)
              | `Rest of Token.t (* "restore" *)
            ]
          * (
                anon_choice_id_f2cdd14
              * (Token.t (* "," *) * anon_choice_id_f2cdd14)
                  list (* zero or more *)
            )
              option
        )
      | `Chec_str_lit_str_lit_str_lit of (
            Token.t (* "checksum" *) * string_literal * string_literal
          * string_literal
        )
    ]
  * pat_1d78758
)

type alias_qualified_name (* inlined *) = (
    identifier * Token.t (* "::" *) * simple_name
)

type and_pattern (* inlined *) = (pattern * Token.t (* "and" *) * pattern)

type anonymous_method_expression (* inlined *) = (
    anon_choice_static_d4628a0 list (* zero or more *)
  * Token.t (* "delegate" *)
  * parameter_list option
  * block
)

type anonymous_object_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * Token.t (* "{" *)
  * (
        anonymous_object_member_declarator
      * (Token.t (* "," *) * anonymous_object_member_declarator)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type array_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * array_type
  * initializer_expression option
)

type as_expression (* inlined *) = (
    expression * Token.t (* "as" *) * type_pattern
)

type assignment_expression (* inlined *) = (
    lvalue_expression
  * [
        `EQ of Token.t (* "=" *)
      | `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `GTGTGTEQ of Token.t (* ">>>=" *)
      | `QMARKQMARKEQ of Token.t (* "??=" *)
    ]
  * expression
)

type await_expression (* inlined *) = (Token.t (* "await" *) * expression)

type checked_expression (* inlined *) = (
    anon_choice_chec_7987657 * Token.t (* "(" *) * expression
  * Token.t (* ")" *)
)

type checked_statement (* inlined *) = (anon_choice_chec_7987657 * block)

type conditional_access_expression (* inlined *) = (
    expression
  * Token.t (* "?" *)
  * [
        `Member_bind_exp of member_binding_expression
      | `Brac_arg_list of bracketed_argument_list
    ]
)

type conditional_expression (* inlined *) = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * expression
)

type constructor_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * identifier
  * parameter_list
  * constructor_initializer option
  * function_body
)

type conversion_operator_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * [ `Impl of Token.t (* "implicit" *) | `Expl of Token.t (* "explicit" *) ]
  * explicit_interface_specifier option
  * Token.t (* "operator" *)
  * Token.t (* "checked" *) option
  * type_pattern
  * parameter_list
  * function_body
)

type declaration_pattern (* inlined *) = (
    type_pattern * variable_designation
)

type destructor_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * Token.t (* "extern" *) option
  * Token.t (* "~" *)
  * identifier
  * parameter_list
  * function_body
)

type do_statement (* inlined *) = (
    Token.t (* "do" *) * global_statement * Token.t (* "while" *)
  * Token.t (* "(" *) * expression * Token.t (* ")" *) * Token.t (* ";" *)
)

type element_access_expression (* inlined *) = (
    expression * bracketed_argument_list
)

type event_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "event" *)
  * type_pattern
  * explicit_interface_specifier option
  * identifier
  * [ `Acce_list of accessor_list | `SEMI of Token.t (* ";" *) ]
)

type event_field_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "event" *)
  * variable_declaration
  * Token.t (* ";" *)
)

type field_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * variable_declaration
  * Token.t (* ";" *)
)

type file_scoped_namespace_declaration (* inlined *) = (
    global_statement list (* zero or more *)
  * namespace_member_declaration list (* zero or more *)
  * Token.t (* "namespace" *)
  * name
  * Token.t (* ";" *)
)

type fixed_statement (* inlined *) = (
    Token.t (* "fixed" *) * Token.t (* "(" *) * variable_declaration
  * Token.t (* ")" *) * global_statement
)

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * [
        `Var_decl of variable_declaration
      | `Exp_rep_COMMA_exp of (
            expression
          * interpolation_alignment_clause list (* zero or more *)
        )
    ]
      option
  * Token.t (* ";" *)
  * expression option
  * Token.t (* ";" *)
  * anon_opt_exp_rep_interp_alig_clause_cd88eaa
  * Token.t (* ")" *)
  * global_statement
)

type foreach_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "foreach" *)
  * Token.t (* "(" *)
  * [
        `Type_choice_id of (type_pattern * anon_choice_id_bf14316)
      | `Exp of expression
    ]
  * Token.t (* "in" *)
  * expression
  * Token.t (* ")" *)
  * global_statement
)

type generic_name (* inlined *) = (identifier * type_argument_list)

type global_attribute (* inlined *) = (
    Token.t (* "[" *)
  * [ `Asse of Token.t (* "assembly" *) | `Module of Token.t (* "module" *) ]
  * Token.t (* ":" *)
  * attribute
  * (Token.t (* "," *) * attribute) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

type goto_statement (* inlined *) = (
    Token.t (* "goto" *)
  * [ `Case of Token.t (* "case" *) | `Defa of Token.t (* "default" *) ]
      option
  * expression option
  * Token.t (* ";" *)
)

type group_clause (* inlined *) = (
    Token.t (* "group" *) * expression * Token.t (* "by" *) * expression
)

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * Token.t (* "(" *)
  * expression
  * Token.t (* ")" *)
  * global_statement
  * (Token.t (* "else" *) * global_statement) option
)

type implicit_array_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * Token.t (* "[" *)
  * Token.t (* "," *) list (* zero or more *)
  * Token.t (* "]" *)
  * initializer_expression
)

type implicit_object_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * argument_list
  * initializer_expression option
)

type implicit_stackalloc_expression (* inlined *) = (
    Token.t (* "stackalloc" *) * Token.t (* "[" *) * Token.t (* "]" *)
  * initializer_expression
)

type indexer_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * explicit_interface_specifier option
  * Token.t (* "this" *)
  * bracketed_parameter_list
  * [
        `Acce_list of accessor_list
      | `Arrow_exp_clause_SEMI of (
            arrow_expression_clause * Token.t (* ";" *)
        )
    ]
)

type is_expression (* inlined *) = (
    expression * Token.t (* "is" *) * type_pattern
)

type is_pattern_expression (* inlined *) = (
    expression * Token.t (* "is" *) * pattern
)

type join_clause (* inlined *) = (
    Token.t (* "join" *)
  * join_header
  * join_body
  * join_into_clause option
)

type labeled_statement (* inlined *) = (
    identifier * Token.t (* ":" *) * global_statement
)

type lambda_expression (* inlined *) = (
    attribute_list list (* zero or more *)
  * anon_choice_static_d4628a0 list (* zero or more *)
  * type_pattern option
  * lambda_parameters
  * Token.t (* "=>" *)
  * [ `Blk of block | `Exp of expression ]
)

type let_clause (* inlined *) = (
    Token.t (* "let" *) * identifier * Token.t (* "=" *) * expression
)

type list_pattern (* inlined *) = (
    Token.t (* "[" *)
  * (
        anon_choice_pat_9cb1b05
      * (Token.t (* "," *) * anon_choice_pat_9cb1b05) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "]" *)
)

type local_declaration_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "using" *) option
  * modifier list (* zero or more *)
  * variable_declaration
  * Token.t (* ";" *)
)

type local_function_statement (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * identifier
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * function_body
)

type lock_statement (* inlined *) = (
    Token.t (* "lock" *) * Token.t (* "(" *) * expression * Token.t (* ")" *)
  * global_statement
)

type makeref_expression (* inlined *) = (
    Token.t (* "__makeref" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *)
)

type method_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * explicit_interface_specifier option
  * identifier
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * function_body
)

type negated_pattern (* inlined *) = (Token.t (* "not" *) * pattern)

type object_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * type_pattern
  * argument_list option
  * initializer_expression option
)

type operator_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * explicit_interface_specifier option
  * Token.t (* "operator" *)
  * Token.t (* "checked" *) option
  * [
        `BANG of Token.t (* "!" *)
      | `TILDE of Token.t (* "~" *)
      | `PLUSPLUS of Token.t (* "++" *)
      | `DASHDASH of Token.t (* "--" *)
      | `True of Token.t (* "true" *)
      | `False of Token.t (* "false" *)
      | `PLUS of Token.t (* "+" *)
      | `DASH of Token.t (* "-" *)
      | `STAR of Token.t (* "*" *)
      | `SLASH of Token.t (* "/" *)
      | `PERC of Token.t (* "%" *)
      | `HAT of Token.t (* "^" *)
      | `BAR of Token.t (* "|" *)
      | `AMP of Token.t (* "&" *)
      | `LTLT of Token.t (* "<<" *)
      | `GTGT of Token.t (* ">>" *)
      | `GTGTGT of Token.t (* ">>>" *)
      | `EQEQ of Token.t (* "==" *)
      | `BANGEQ of Token.t (* "!=" *)
      | `GT of Token.t (* ">" *)
      | `LT of Token.t (* "<" *)
      | `GTEQ of Token.t (* ">=" *)
      | `LTEQ of Token.t (* "<=" *)
    ]
  * parameter_list
  * function_body
)

type or_pattern (* inlined *) = (pattern * Token.t (* "or" *) * pattern)

type order_by_clause (* inlined *) = (
    Token.t (* "orderby" *)
  * ordering
  * (Token.t (* "," *) * ordering) list (* zero or more *)
)

type parameter_array (* inlined *) = (
    attribute_list list (* zero or more *)
  * Token.t (* "params" *)
  * [ `Array_type of array_type | `Null_type of nullable_type ]
  * identifier
)

type parenthesized_lvalue_expression (* inlined *) = (
    Token.t (* "(" *) * lvalue_expression * Token.t (* ")" *)
)

type parenthesized_pattern (* inlined *) = (
    Token.t (* "(" *) * pattern * Token.t (* ")" *)
)

type pointer_indirection_expression (* inlined *) = (
    Token.t (* "*" *) * lvalue_expression
)

type preproc_elif (* inlined *) = (
    pat_bfeb4bb
  * preproc_expression
  * pat_1d78758
  * declaration list (* zero or more *)
  * anon_choice_prep_else_8b52b0f option
)

type preproc_elif_in_enum_member_declaration (* inlined *) = (
    pat_bfeb4bb
  * preproc_expression
  * pat_1d78758
  * enum_member_declaration option
  * anon_choice_prep_else_in_enum_member_decl_ef97f12 option
)

type preproc_elif_in_expression (* inlined *) = (
    pat_bfeb4bb
  * preproc_expression
  * pat_1d78758
  * expression option
  * anon_choice_prep_else_in_exp_678167b option
)

type preproc_elif_in_top_level (* inlined *) = (
    pat_bfeb4bb
  * preproc_expression
  * pat_1d78758
  * anon_choice_top_level_item_no_stmt_65e2afd list (* zero or more *)
  * anon_choice_prep_else_in_top_level_0825411 option
)

type preproc_else (* inlined *) = (
    pat_56631e5
  * declaration list (* zero or more *)
)

type preproc_else_in_enum_member_declaration (* inlined *) = (
    pat_56631e5
  * enum_member_declaration option
)

type preproc_else_in_expression (* inlined *) = (
    pat_56631e5
  * expression option
)

type preproc_else_in_top_level (* inlined *) = (
    pat_56631e5
  * anon_choice_top_level_item_no_stmt_65e2afd list (* zero or more *)
)

type preproc_if (* inlined *) = (
    pat_3df6e71
  * preproc_expression
  * pat_1d78758
  * declaration list (* zero or more *)
  * anon_choice_prep_else_8b52b0f option
  * pat_c46d1b2
)

type preproc_if_in_enum_member_declaration (* inlined *) = (
    pat_3df6e71
  * preproc_expression
  * pat_1d78758
  * enum_member_declaration option
  * anon_choice_prep_else_in_enum_member_decl_ef97f12 option
  * pat_c46d1b2
)

type preproc_if_in_expression (* inlined *) = (
    pat_3df6e71
  * preproc_expression
  * pat_1d78758
  * expression option
  * anon_choice_prep_else_in_exp_678167b option
  * pat_c46d1b2
)

type property_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * explicit_interface_specifier option
  * identifier
  * [
        `Acce_list_opt_EQ_exp_SEMI of (
            accessor_list
          * (Token.t (* "=" *) * expression * Token.t (* ";" *)) option
        )
      | `Arrow_exp_clause_SEMI of (
            arrow_expression_clause * Token.t (* ";" *)
        )
    ]
)

type qualified_name (* inlined *) = (name * Token.t (* "." *) * simple_name)

type query_expression (* inlined *) = (from_clause * query_body)

type range_expression (* inlined *) = (
    expression option
  * Token.t (* ".." *)
  * expression option
)

type recursive_pattern (* inlined *) = (
    type_pattern option
  * [
        `Posi_pat_clause_opt_prop_pat_clause of (
            positional_pattern_clause
          * property_pattern_clause option
        )
      | `Prop_pat_clause of property_pattern_clause
    ]
  * variable_designation option
)

type ref_expression (* inlined *) = (Token.t (* "ref" *) * expression)

type reftype_expression (* inlined *) = (
    Token.t (* "__reftype" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *)
)

type refvalue_expression (* inlined *) = (
    Token.t (* "__refvalue" *) * Token.t (* "(" *) * expression
  * Token.t (* "," *) * type_pattern * Token.t (* ")" *)
)

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * expression option
  * Token.t (* ";" *)
)

type scoped_type (* inlined *) = (Token.t (* "scoped" *) * scoped_base_type)

type select_clause (* inlined *) = (Token.t (* "select" *) * expression)

type stackalloc_expression (* inlined *) = (
    Token.t (* "stackalloc" *)
  * array_type
  * initializer_expression option
)

type switch_expression (* inlined *) = (
    expression
  * Token.t (* "switch" *)
  * Token.t (* "{" *)
  * (
        switch_expression_arm
      * (Token.t (* "," *) * switch_expression_arm) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type switch_statement (* inlined *) = (
    Token.t (* "switch" *)
  * [
        `LPAR_exp_RPAR of (Token.t (* "(" *) * expression * Token.t (* ")" *))
      | `Tuple_exp of tuple_expression
    ]
  * switch_body
)

type throw_expression (* inlined *) = (Token.t (* "throw" *) * expression)

type throw_statement (* inlined *) = (
    Token.t (* "throw" *)
  * expression option
  * Token.t (* ";" *)
)

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * block
  * catch_clause list (* zero or more *)
  * finally_clause option
)

type unsafe_statement (* inlined *) = (Token.t (* "unsafe" *) * block)

type using_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "using" *)
  * Token.t (* "(" *)
  * [ `Using_var_decl of using_variable_declaration | `Exp of expression ]
  * Token.t (* ")" *)
  * global_statement
)

type where_clause (* inlined *) = (Token.t (* "where" *) * expression)

type while_statement (* inlined *) = (
    Token.t (* "while" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *) * global_statement
)

type with_expression (* inlined *) = (
    expression
  * Token.t (* "with" *)
  * Token.t (* "{" *)
  * (
        with_initializer
      * (Token.t (* "," *) * with_initializer) list (* zero or more *)
    )
      option
  * Token.t (* "}" *)
)

type yield_statement (* inlined *) = (
    Token.t (* "yield" *)
  * [
        `Ret_exp of (Token.t (* "return" *) * expression)
      | `Brk of Token.t (* "break" *)
    ]
  * Token.t (* ";" *)
)

type semgrep_expression (* inlined *) = (
    Token.t (* "__SEMGREP_EXPRESSION" *) * expression
)

type object_creation_type (* inlined *) = [
    `Name of name
  | `Null_type of nullable_type
  | `Pred_type of predefined_type (*tok*)
]

type extra = [
    `Comment of Loc.t * comment
  | `Preproc_region of Loc.t * preproc_region
  | `Preproc_endregion of Loc.t * preproc_endregion
  | `Preproc_line of Loc.t * preproc_line
  | `Preproc_pragma of Loc.t * preproc_pragma
  | `Preproc_nullable of Loc.t * preproc_nullable
  | `Preproc_error of Loc.t * preproc_error
  | `Preproc_warning of Loc.t * preproc_warning
  | `Preproc_define of Loc.t * preproc_define
  | `Preproc_undef of Loc.t * preproc_undef
]

type extras = extra list
