(* Generated by ocaml-tree-sitter. *)
(*
   c_sharp grammar

   entrypoint: compilation_unit
*)

open! Sexplib.Conv
open Tree_sitter_run

type identifier_token = Token.t
[@@deriving sexp_of]

type modifier = [
    `Abst of Token.t (* "abstract" *)
  | `Async of Token.t (* "async" *)
  | `Const of Token.t (* "const" *)
  | `Extern of Token.t (* "extern" *)
  | `Fixed of Token.t (* "fixed" *)
  | `Inte of Token.t (* "internal" *)
  | `New of Token.t (* "new" *)
  | `Over of Token.t (* "override" *)
  | `Part of Token.t (* "partial" *)
  | `Priv of Token.t (* "private" *)
  | `Prot of Token.t (* "protected" *)
  | `Public of Token.t (* "public" *)
  | `Read of Token.t (* "readonly" *)
  | `Ref of Token.t (* "ref" *)
  | `Sealed of Token.t (* "sealed" *)
  | `Static of Token.t (* "static" *)
  | `Unsafe of Token.t (* "unsafe" *)
  | `Virt of Token.t (* "virtual" *)
  | `Vola of Token.t (* "volatile" *)
]
[@@deriving sexp_of]

type verbatim_string_literal = Token.t
[@@deriving sexp_of]

type interpolated_string_text_fragment =
  Token.t (* pattern "[^{\"\\\\\\n]+" *)
[@@deriving sexp_of]

type preproc_directive_start = Token.t (* pattern #[ \t]* *)
[@@deriving sexp_of]

type real_literal = Token.t
[@@deriving sexp_of]

type predefined_type = Token.t
[@@deriving sexp_of]

type interpolated_verbatim_string_text_fragment =
  Token.t (* pattern "[^{\"]+" *)
[@@deriving sexp_of]

type preproc_message = Token.t (* pattern [^\n\r]+ *)
[@@deriving sexp_of]

type overloadable_operator = [
    `BANG of Token.t (* "!" *)
  | `TILDE of Token.t (* "~" *)
  | `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
  | `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
  | `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
  | `STAR of Token.t (* "*" *)
  | `SLASH of Token.t (* "/" *)
  | `PERC of Token.t (* "%" *)
  | `HAT of Token.t (* "^" *)
  | `BAR of Token.t (* "|" *)
  | `AMP of Token.t (* "&" *)
  | `LTLT of Token.t (* "<<" *)
  | `GTGT of Token.t (* ">>" *)
  | `EQEQ of Token.t (* "==" *)
  | `BANGEQ of Token.t (* "!=" *)
  | `GT of Token.t (* ">" *)
  | `LT of Token.t (* "<" *)
  | `GTEQ of Token.t (* ">=" *)
  | `LTEQ of Token.t (* "<=" *)
]
[@@deriving sexp_of]

type attribute_target_specifier = (
    [
        `Field of Token.t (* "field" *)
      | `Event of Token.t (* "event" *)
      | `Meth of Token.t (* "method" *)
      | `Param of Token.t (* "param" *)
      | `Prop of Token.t (* "property" *)
      | `Ret of Token.t (* "return" *)
      | `Type of Token.t (* "type" *)
    ]
  * Token.t (* ":" *)
)
[@@deriving sexp_of]

type parameter_modifier = [
    `Ref of Token.t (* "ref" *)
  | `Out of Token.t (* "out" *)
  | `This of Token.t (* "this" *)
  | `In of Token.t (* "in" *)
]
[@@deriving sexp_of]

type string_literal_fragment = Token.t (* pattern "[^\"\\\\\\n]+" *)
[@@deriving sexp_of]

type imm_tok_pat_684220d = Token.t (* pattern "[^'\\\\]" *)
[@@deriving sexp_of]

type preproc_directive_end = Token.t
[@@deriving sexp_of]

type pat_52ffbd7 = Token.t (* pattern "[^}\"]+" *)
[@@deriving sexp_of]

type anon_choice_DOT_2ad1dab = [
    `DOT of Token.t (* "." *)
  | `DASHGT of Token.t (* "->" *)
]
[@@deriving sexp_of]

type default_switch_label = (Token.t (* "default" *) * Token.t (* ":" *))
[@@deriving sexp_of]

type nullable_directive = (
    Token.t (* "nullable" *)
  * [
        `Disa of Token.t (* "disable" *)
      | `Enable of Token.t (* "enable" *)
      | `Rest of Token.t (* "restore" *)
    ]
  * [
        `Annots of Token.t (* "annotations" *)
      | `Warnis of Token.t (* "warnings" *)
    ]
      option
)
[@@deriving sexp_of]

type contextual_keywords = [
    `Asce of Token.t (* "ascending" *)
  | `By of Token.t (* "by" *)
  | `Desc of Token.t (* "descending" *)
  | `Equals of Token.t (* "equals" *)
  | `From of Token.t (* "from" *)
  | `Group of Token.t (* "group" *)
  | `Into of Token.t (* "into" *)
  | `Join of Token.t (* "join" *)
  | `Let of Token.t (* "let" *)
  | `On of Token.t (* "on" *)
  | `Orde of Token.t (* "orderby" *)
  | `Select of Token.t (* "select" *)
  | `Where of Token.t (* "where" *)
  | `Add of Token.t (* "add" *)
  | `Get of Token.t (* "get" *)
  | `Remove of Token.t (* "remove" *)
  | `Set of Token.t (* "set" *)
  | `Global of Token.t (* "global" *)
  | `Alias of Token.t (* "alias" *)
  | `Dyna of Token.t (* "dynamic" *)
  | `Nameof of Token.t (* "nameof" *)
  | `Notn of Token.t (* "notnull" *)
  | `Unma of Token.t (* "unmanaged" *)
  | `When of Token.t (* "when" *)
  | `Yield of Token.t (* "yield" *)
]
[@@deriving sexp_of]

type semgrep_metavariable = Token.t
[@@deriving sexp_of]

type integer_literal = Token.t
[@@deriving sexp_of]

type preproc_string_literal = Token.t (* pattern "\"[^\"]*\"" *)
[@@deriving sexp_of]

type boolean_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]
[@@deriving sexp_of]

type escape_sequence = Token.t
[@@deriving sexp_of]

type preproc_integer_literal = Token.t (* pattern [0-9]+ *)
[@@deriving sexp_of]

type assignment_operator = [
    `EQ of Token.t (* "=" *)
  | `PLUSEQ of Token.t (* "+=" *)
  | `DASHEQ of Token.t (* "-=" *)
  | `STAREQ of Token.t (* "*=" *)
  | `SLASHEQ of Token.t (* "/=" *)
  | `PERCEQ of Token.t (* "%=" *)
  | `AMPEQ of Token.t (* "&=" *)
  | `HATEQ of Token.t (* "^=" *)
  | `BAREQ of Token.t (* "|=" *)
  | `LTLTEQ of Token.t (* "<<=" *)
  | `GTGTEQ of Token.t (* ">>=" *)
  | `QMARKQMARKEQ of Token.t (* "??=" *)
]
[@@deriving sexp_of]

type interpolated_verbatim_string_text = [
    `LCURLLCURL of Token.t (* "{{" *)
  | `Inte_verb_str_text_frag of
      interpolated_verbatim_string_text_fragment (*tok*)
  | `DQUOTDQUOT of Token.t (* "\"\"" *)
]
[@@deriving sexp_of]

type warning_directive = (Token.t (* "warning" *) * preproc_message (*tok*))
[@@deriving sexp_of]

type error_directive = (Token.t (* "error" *) * preproc_message (*tok*))
[@@deriving sexp_of]

type endregion_directive = (
    Token.t (* "endregion" *)
  * preproc_message (*tok*) option
)
[@@deriving sexp_of]

type region_directive = (
    Token.t (* "region" *)
  * preproc_message (*tok*) option
)
[@@deriving sexp_of]

type interpolation_format_clause = (Token.t (* ":" *) * pat_52ffbd7 (*tok*))
[@@deriving sexp_of]

type identifier = [
    `Choice_id_tok of [
        `Id_tok of identifier_token (*tok*)
      | `Cont_keywos of contextual_keywords
    ]
  | `Semg_meta of semgrep_metavariable (*tok*)
]
[@@deriving sexp_of]

type interpolated_string_text = [
    `LCURLLCURL of Token.t (* "{{" *)
  | `Inte_str_text_frag of interpolated_string_text_fragment (*tok*)
  | `Esc_seq of escape_sequence (*tok*)
]
[@@deriving sexp_of]

type line_directive = (
    Token.t (* "line" *)
  * [
        `Defa of Token.t (* "default" *)
      | `Hidden of Token.t (* "hidden" *)
      | `Prep_int_lit_opt_prep_str_lit of (
            preproc_integer_literal (*tok*)
          * preproc_string_literal (*tok*) option
        )
    ]
)
[@@deriving sexp_of]

type preproc_binary_expression = [
    `Prep_exp_BARBAR_prep_exp of (
        preproc_expression * Token.t (* "||" *) * preproc_expression
    )
  | `Prep_exp_AMPAMP_prep_exp of (
        preproc_expression * Token.t (* "&&" *) * preproc_expression
    )
  | `Prep_exp_EQEQ_prep_exp of (
        preproc_expression * Token.t (* "==" *) * preproc_expression
    )
  | `Prep_exp_BANGEQ_prep_exp of (
        preproc_expression * Token.t (* "!=" *) * preproc_expression
    )
]

and preproc_expression = [
    `Id of identifier
  | `Bool_lit of boolean_literal
  | `Prep_int_lit of preproc_integer_literal (*tok*)
  | `Prep_str_lit of preproc_string_literal (*tok*)
  | `Prep_un_exp of (Token.t (* "!" *) * preproc_expression)
  | `Prep_bin_exp of preproc_binary_expression
  | `Prep_paren_exp of (
        Token.t (* "(" *) * preproc_expression * Token.t (* ")" *)
    )
]
[@@deriving sexp_of]

type define_directive = (Token.t (* "define" *) * identifier)
[@@deriving sexp_of]

type anon_choice_id_c290f8e = [
    `Id of identifier
  | `Prep_int_lit of preproc_integer_literal (*tok*)
]
[@@deriving sexp_of]

type anon_choice_id_c036834 = [
    `Id of identifier
  | `Disc of Token.t (* "_" *)
  | `Tuple_pat of tuple_pattern
]

and tuple_pattern = (
    Token.t (* "(" *)
  * anon_choice_id_c036834
  * (Token.t (* "," *) * anon_choice_id_c036834) list (* zero or more *)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type undef_directive = (Token.t (* "undef" *) * identifier)
[@@deriving sexp_of]

type variable_designation = [
    `Disc of Token.t (* "_" *)
  | `Paren_var_desi of (
        Token.t (* "(" *)
      * (
            variable_designation
          * (Token.t (* "," *) * variable_designation)
              list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
    )
  | `Id of identifier
]
[@@deriving sexp_of]

type function_pointer_unmanaged_calling_convention = [
    `Cdecl of Token.t (* "Cdecl" *)
  | `Stdc of Token.t (* "Stdcall" *)
  | `This of Token.t (* "Thiscall" *)
  | `Fast of Token.t (* "Fastcall" *)
  | `Id of identifier
]
[@@deriving sexp_of]

type join_into_clause = (Token.t (* "into" *) * identifier)
[@@deriving sexp_of]

type identifier_or_global = [
    `Global of Token.t (* "global" *)
  | `Id of identifier
]
[@@deriving sexp_of]

type extern_alias_directive = (
    Token.t (* "extern" *) * Token.t (* "alias" *) * identifier
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type literal = [
    `Null_lit of Token.t (* "null" *)
  | `Bool_lit of boolean_literal
  | `Char_lit of (
        Token.t (* "'" *)
      * [
            `Imm_tok_pat_684220d of imm_tok_pat_684220d (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
      * Token.t (* "'" *)
    )
  | `Real_lit of real_literal (*tok*)
  | `Int_lit of integer_literal (*tok*)
  | `Str_lit of (
        Token.t (* "\"" *)
      * [
            `Str_lit_frag of string_literal_fragment (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `Verb_str_lit of verbatim_string_literal (*tok*)
]
[@@deriving sexp_of]

type if_directive = (Token.t (* "if" *) * preproc_expression)
[@@deriving sexp_of]

type elif_directive = (Token.t (* "elif" *) * preproc_expression)
[@@deriving sexp_of]

type pragma_directive = (
    Token.t (* "pragma" *)
  * [
        `Warn_choice_disa_opt_choice_id_rep_COMMA_choice_id of (
            Token.t (* "warning" *)
          * [
                `Disa of Token.t (* "disable" *)
              | `Rest of Token.t (* "restore" *)
            ]
          * (
                anon_choice_id_c290f8e
              * (Token.t (* "," *) * anon_choice_id_c290f8e)
                  list (* zero or more *)
            )
              option
        )
      | `Chec_prep_str_lit_prep_str_lit_prep_str_lit of (
            Token.t (* "checksum" *) * preproc_string_literal (*tok*)
          * preproc_string_literal (*tok*) * preproc_string_literal (*tok*)
        )
    ]
)
[@@deriving sexp_of]

type anon_choice_id_bf14316 = [
    `Id of identifier
  | `Tuple_pat of tuple_pattern
]
[@@deriving sexp_of]

type function_pointer_unmanaged_calling_convention_list = (
    Token.t (* "[" *)
  * function_pointer_unmanaged_calling_convention
  * (Token.t (* "," *) * function_pointer_unmanaged_calling_convention)
      list (* zero or more *)
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type name_equals = (identifier_or_global * Token.t (* "=" *))
[@@deriving sexp_of]

type name_colon = (identifier_or_global * Token.t (* ":" *))
[@@deriving sexp_of]

type function_pointer_calling_convention = [
    `Mana of Token.t (* "managed" *)
  | `Unma_opt_func_poin_unma_call_conv_list of (
        Token.t (* "unmanaged" *)
      * function_pointer_unmanaged_calling_convention_list option
    )
]
[@@deriving sexp_of]

type anon_choice_cst_pat_3bb8381 = [
    `Exp of constant_pattern
  | `Pred_type of predefined_type (*tok*)
  | `Name of name
]

and anon_choice_param_ce11a32 = [
    `Param of parameter
  | `Param_array of (
        attribute_list list (* zero or more *)
      * Token.t (* "params" *)
      * [ `Array_type of array_type | `Null_type of nullable_type ]
      * identifier
    )
]

and anon_opt_cst_pat_rep_interp_alig_clause_080fdff =
  (constant_pattern * interpolation_alignment_clause list (* zero or more *))
    option

and anonymous_object_member_declarator = [
    `Name_equals_exp of (name_equals * constant_pattern)
  | `Exp of constant_pattern
]

and argument = (
    name_colon option
  * [
        `Ref of Token.t (* "ref" *)
      | `Out of Token.t (* "out" *)
      | `In of Token.t (* "in" *)
    ]
      option
  * [ `Exp of constant_pattern | `Decl_exp of declaration_expression ]
)

and argument_list = (
    Token.t (* "(" *)
  * (argument * (Token.t (* "," *) * argument) list (* zero or more *))
      option
  * Token.t (* ")" *)
)

and array_rank_specifier = (
    Token.t (* "[" *)
  * (
        constant_pattern option
      * (Token.t (* "," *) * constant_pattern option) list (* zero or more *)
    )
      option
  * Token.t (* "]" *)
)

and array_type = (type_pattern * array_rank_specifier)

and arrow_expression_clause = (Token.t (* "=>" *) * constant_pattern)

and attribute = (name * attribute_argument_list option)

and attribute_argument = (
    [ `Name_equals of name_equals | `Name_colon of name_colon ] option
  * constant_pattern
)

and attribute_argument_list = (
    Token.t (* "(" *)
  * (
        attribute_argument
      * (Token.t (* "," *) * attribute_argument) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and attribute_list = (
    Token.t (* "[" *)
  * attribute_target_specifier option
  * attribute
  * (Token.t (* "," *) * attribute) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

and binary_expression = [
    `Exp_AMPAMP_exp of (
        constant_pattern * Token.t (* "&&" *) * constant_pattern
    )
  | `Exp_BARBAR_exp of (
        constant_pattern * Token.t (* "||" *) * constant_pattern
    )
  | `Exp_GTGT_exp of (
        constant_pattern * Token.t (* ">>" *) * constant_pattern
    )
  | `Exp_LTLT_exp of (
        constant_pattern * Token.t (* "<<" *) * constant_pattern
    )
  | `Exp_AMP_exp of (constant_pattern * Token.t (* "&" *) * constant_pattern)
  | `Exp_HAT_exp of (constant_pattern * Token.t (* "^" *) * constant_pattern)
  | `Exp_BAR_exp of (constant_pattern * Token.t (* "|" *) * constant_pattern)
  | `Exp_PLUS_exp of (
        constant_pattern * Token.t (* "+" *) * constant_pattern
    )
  | `Exp_DASH_exp of (
        constant_pattern * Token.t (* "-" *) * constant_pattern
    )
  | `Exp_STAR_exp of (
        constant_pattern * Token.t (* "*" *) * constant_pattern
    )
  | `Exp_SLASH_exp of (
        constant_pattern * Token.t (* "/" *) * constant_pattern
    )
  | `Exp_PERC_exp of (
        constant_pattern * Token.t (* "%" *) * constant_pattern
    )
  | `Exp_LT_exp of (constant_pattern * Token.t (* "<" *) * constant_pattern)
  | `Exp_LTEQ_exp of (
        constant_pattern * Token.t (* "<=" *) * constant_pattern
    )
  | `Exp_EQEQ_exp of (
        constant_pattern * Token.t (* "==" *) * constant_pattern
    )
  | `Exp_BANGEQ_exp of (
        constant_pattern * Token.t (* "!=" *) * constant_pattern
    )
  | `Exp_GTEQ_exp of (
        constant_pattern * Token.t (* ">=" *) * constant_pattern
    )
  | `Exp_GT_exp of (constant_pattern * Token.t (* ">" *) * constant_pattern)
  | `Exp_QMARKQMARK_exp of (
        constant_pattern * Token.t (* "??" *) * constant_pattern
    )
]

and binary_pattern = [
    `Pat_and_pat of (pattern * Token.t (* "and" *) * pattern)
  | `Pat_or_pat of (pattern * Token.t (* "or" *) * pattern)
]

and block = (
    Token.t (* "{" *)
  * global_statement list (* zero or more *)
  * Token.t (* "}" *)
)

and bracketed_argument_list = (
    Token.t (* "[" *)
  * argument
  * (Token.t (* "," *) * argument) list (* zero or more *)
  * Token.t (* "]" *)
)

and case_pattern_switch_label = (
    Token.t (* "case" *)
  * pattern
  * when_clause option
  * Token.t (* ":" *)
)

and case_switch_label = (
    Token.t (* "case" *) * constant_pattern * Token.t (* ":" *)
)

and catch_clause = (
    Token.t (* "catch" *)
  * catch_declaration option
  * catch_filter_clause option
  * block
)

and catch_declaration = (
    Token.t (* "(" *)
  * type_pattern
  * identifier option
  * Token.t (* ")" *)
)

and catch_filter_clause = (
    Token.t (* "when" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* ")" *)
)

and checked_expression = [
    `Chec_LPAR_exp_RPAR of (
        Token.t (* "checked" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *)
    )
  | `Unch_LPAR_exp_RPAR of (
        Token.t (* "unchecked" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *)
    )
]

and constant_pattern = expression

and declaration_expression = (type_pattern * identifier)

and element_binding_expression = bracketed_argument_list

and equals_value_clause = (Token.t (* "=" *) * constant_pattern)

and expression = [
    `Anon_meth_exp of (
        Token.t (* "async" *) option
      * Token.t (* "delegate" *)
      * parameter_list option
      * block
    )
  | `Anon_obj_crea_exp of (
        Token.t (* "new" *)
      * Token.t (* "{" *)
      * (
            anonymous_object_member_declarator
          * (Token.t (* "," *) * anonymous_object_member_declarator)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Array_crea_exp of (
        Token.t (* "new" *)
      * array_type
      * initializer_expression option
    )
  | `As_exp of (constant_pattern * Token.t (* "as" *) * type_pattern)
  | `Assign_exp of (
        constant_pattern * assignment_operator * constant_pattern
    )
  | `Await_exp of (Token.t (* "await" *) * constant_pattern)
  | `Base_exp of Token.t (* "base" *)
  | `Bin_exp of binary_expression
  | `Cast_exp of (
        Token.t (* "(" *) * type_pattern * Token.t (* ")" *)
      * constant_pattern
    )
  | `Chec_exp of checked_expression
  | `Cond_access_exp of (
        constant_pattern
      * Token.t (* "?" *)
      * [
            `Member_bind_exp of member_binding_expression
          | `Elem_bind_exp of element_binding_expression
        ]
    )
  | `Cond_exp of (
        constant_pattern * Token.t (* "?" *) * constant_pattern
      * Token.t (* ":" *) * constant_pattern
    )
  | `Defa_exp of (
        Token.t (* "default" *)
      * (Token.t (* "(" *) * type_pattern * Token.t (* ")" *)) option
    )
  | `Elem_access_exp of (constant_pattern * element_binding_expression)
  | `Elem_bind_exp of element_binding_expression
  | `Impl_array_crea_exp of (
        Token.t (* "new" *)
      * Token.t (* "[" *)
      * Token.t (* "," *) list (* zero or more *)
      * Token.t (* "]" *)
      * initializer_expression
    )
  | `Impl_obj_crea_exp of (
        Token.t (* "new" *)
      * argument_list
      * initializer_expression option
    )
  | `Impl_stack_alloc_array_crea_exp of (
        Token.t (* "stackalloc" *) * Token.t (* "[" *) * Token.t (* "]" *)
      * initializer_expression
    )
  | `Init_exp of initializer_expression
  | `Inte_str_exp of interpolated_string_expression
  | `Invo_exp of (constant_pattern * argument_list)
  | `Is_exp of (constant_pattern * Token.t (* "is" *) * type_pattern)
  | `Is_pat_exp of (constant_pattern * Token.t (* "is" *) * pattern)
  | `Lambda_exp of (
        Token.t (* "async" *) option
      * Token.t (* "static" *) option
      * [ `Param_list of parameter_list | `Id of identifier ]
      * Token.t (* "=>" *)
      * [ `Blk of block | `Exp of constant_pattern ]
    )
  | `Make_ref_exp of (
        Token.t (* "__makeref" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *)
    )
  | `Member_access_exp of (
        anon_choice_cst_pat_3bb8381 * anon_choice_DOT_2ad1dab * simple_name
    )
  | `Obj_crea_exp of (
        Token.t (* "new" *)
      * type_pattern
      * argument_list option
      * initializer_expression option
    )
  | `Paren_exp of parenthesized_expression
  | `Post_un_exp of postfix_unary_expression
  | `Prefix_un_exp of prefix_unary_expression
  | `Query_exp of (from_clause * query_body)
  | `Range_exp of (
        constant_pattern option
      * Token.t (* ".." *)
      * constant_pattern option
    )
  | `Ref_exp of (Token.t (* "ref" *) * constant_pattern)
  | `Ref_type_exp of (
        Token.t (* "__reftype" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *)
    )
  | `Ref_value_exp of (
        Token.t (* "__refvalue" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* "," *) * type_pattern * Token.t (* ")" *)
    )
  | `Size_of_exp of (
        Token.t (* "sizeof" *) * Token.t (* "(" *) * type_pattern
      * Token.t (* ")" *)
    )
  | `Stack_alloc_array_crea_exp of (
        Token.t (* "stackalloc" *)
      * array_type
      * initializer_expression option
    )
  | `Switch_exp of (
        constant_pattern
      * Token.t (* "switch" *)
      * Token.t (* "{" *)
      * (
            switch_expression_arm
          * (Token.t (* "," *) * switch_expression_arm)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `This_exp of Token.t (* "this" *)
  | `Throw_exp of (Token.t (* "throw" *) * constant_pattern)
  | `Tuple_exp of tuple_expression
  | `Type_of_exp of (
        Token.t (* "typeof" *) * Token.t (* "(" *) * type_pattern
      * Token.t (* ")" *)
    )
  | `With_exp of (
        constant_pattern
      * Token.t (* "with" *)
      * Token.t (* "{" *)
      * with_initializer_expression option
      * Token.t (* "}" *)
    )
  | `Simple_name of simple_name
  | `Lit of literal
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips of (
        Token.t (* "<..." *) * constant_pattern * Token.t (* "...>" *)
    )
  | `Member_access_ellips_exp of (
        anon_choice_cst_pat_3bb8381 * anon_choice_DOT_2ad1dab
      * Token.t (* "..." *)
    )
]

and expression_statement = [
    `Exp_SEMI of (constant_pattern * Token.t (* ";" *))
  | `Ellips_SEMI of (Token.t (* "..." *) * Token.t (* ";" *))
  | `Ellips of Token.t (* "..." *)
]

and finally_clause = (Token.t (* "finally" *) * block)

and formal_parameter_list = (
    anon_choice_param_ce11a32
  * (Token.t (* "," *) * anon_choice_param_ce11a32) list (* zero or more *)
)

and from_clause = (
    Token.t (* "from" *)
  * type_pattern option
  * identifier
  * Token.t (* "in" *)
  * constant_pattern
)

and function_body = [
    `Blk of block
  | `Arrow_exp_clause_SEMI of (arrow_expression_clause * Token.t (* ";" *))
  | `SEMI of Token.t (* ";" *)
]

and function_pointer_parameter = (
    [
        `Ref of Token.t (* "ref" *)
      | `Out of Token.t (* "out" *)
      | `In of Token.t (* "in" *)
      | `Ref_read of (Token.t (* "ref" *) * Token.t (* "readonly" *))
    ]
      option
  * return_type
)

and global_statement = statement

and initializer_expression = (
    Token.t (* "{" *)
  * anon_opt_cst_pat_rep_interp_alig_clause_080fdff
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and interpolated_string_content = [
    `Inte_str_text of interpolated_string_text
  | `Interp of interpolation
]

and interpolated_string_expression = [
    `DOLLARDQUOT_rep_inte_str_content_DQUOT of (
        Token.t (* "$\"" *)
      * interpolated_string_content list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `DOLLARATDQUOT_rep_inte_verb_str_content_DQUOT of (
        Token.t (* "$@\"" *)
      * interpolated_verbatim_string_content list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `ATDOLLARDQUOT_rep_inte_verb_str_content_DQUOT of (
        Token.t (* "@$\"" *)
      * interpolated_verbatim_string_content list (* zero or more *)
      * Token.t (* "\"" *)
    )
]

and interpolated_verbatim_string_content = [
    `Inte_verb_str_text of interpolated_verbatim_string_text
  | `Interp of interpolation
]

and interpolation = (
    Token.t (* "{" *)
  * constant_pattern
  * interpolation_alignment_clause option
  * interpolation_format_clause option
  * Token.t (* "}" *)
)

and interpolation_alignment_clause = (Token.t (* "," *) * constant_pattern)

and member_binding_expression = (Token.t (* "." *) * simple_name)

and name = [
    `Alias_qual_name of (
        identifier_or_global * Token.t (* "::" *) * simple_name
    )
  | `Qual_name of (name * Token.t (* "." *) * simple_name)
  | `Simple_name of simple_name
]

and nullable_type = [ `Type_QMARK of (type_pattern * Token.t (* "?" *)) ]

and ordering = (
    constant_pattern
  * [
        `Asce of Token.t (* "ascending" *)
      | `Desc of Token.t (* "descending" *)
    ]
      option
)

and parameter = [
    `Rep_attr_list_opt_param_modi_opt_type_id_opt_equals_value_clause of (
        attribute_list list (* zero or more *)
      * parameter_modifier option
      * type_pattern option
      * identifier
      * equals_value_clause option
    )
  | `Ellips of Token.t (* "..." *)
]

and parameter_list = (
    Token.t (* "(" *)
  * formal_parameter_list option
  * Token.t (* ")" *)
)

and parenthesized_expression = (
    Token.t (* "(" *) * constant_pattern * Token.t (* ")" *)
)

and pattern = [
    `Cst_pat of constant_pattern
  | `Decl_pat of (type_pattern * variable_designation)
  | `Disc of Token.t (* "_" *)
  | `Recu_pat of (
        type_pattern option
      * [
            `Posi_pat_clause_opt_prop_pat_clause of (
                positional_pattern_clause
              * property_pattern_clause option
            )
          | `Prop_pat_clause of property_pattern_clause
        ]
      * variable_designation option
    )
  | `Var_pat of (Token.t (* "var" *) * variable_designation)
  | `Nega_pat of (Token.t (* "not" *) * pattern)
  | `Paren_pat of (Token.t (* "(" *) * pattern * Token.t (* ")" *))
  | `Rela_pat of relational_pattern
  | `Bin_pat of binary_pattern
  | `Type_pat of type_pattern
]

and positional_pattern_clause = (
    Token.t (* "(" *)
  * (
        subpattern
      * Token.t (* "," *)
      * subpattern
      * (Token.t (* "," *) * subpattern) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and postfix_unary_expression = [
    `Exp_PLUSPLUS of (constant_pattern * Token.t (* "++" *))
  | `Exp_DASHDASH of (constant_pattern * Token.t (* "--" *))
  | `Exp_BANG of (constant_pattern * Token.t (* "!" *))
]

and prefix_unary_expression = [
    `BANG_exp of (Token.t (* "!" *) * constant_pattern)
  | `AMP_exp of (Token.t (* "&" *) * constant_pattern)
  | `STAR_exp of (Token.t (* "*" *) * constant_pattern)
  | `PLUS_exp of (Token.t (* "+" *) * constant_pattern)
  | `PLUSPLUS_exp of (Token.t (* "++" *) * constant_pattern)
  | `DASH_exp of (Token.t (* "-" *) * constant_pattern)
  | `DASHDASH_exp of (Token.t (* "--" *) * constant_pattern)
  | `HAT_exp of (Token.t (* "^" *) * constant_pattern)
  | `TILDE_exp of (Token.t (* "~" *) * constant_pattern)
]

and property_pattern_clause = (
    Token.t (* "{" *)
  * (subpattern * (Token.t (* "," *) * subpattern) list (* zero or more *))
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and query_body = [
  `Rectype of (
      query_clause list (* zero or more *)
    * select_or_group_clause
    * query_continuation option
  )
]

and query_clause = [
    `From_clause of from_clause
  | `Join_clause of (
        Token.t (* "join" *)
      * type_pattern option
      * identifier
      * Token.t (* "in" *)
      * constant_pattern
      * Token.t (* "on" *)
      * constant_pattern
      * Token.t (* "equals" *)
      * constant_pattern
      * join_into_clause option
    )
  | `Let_clause of (
        Token.t (* "let" *) * identifier * Token.t (* "=" *)
      * constant_pattern
    )
  | `Order_by_clause of (
        Token.t (* "orderby" *)
      * ordering
      * (Token.t (* "," *) * ordering) list (* zero or more *)
    )
  | `Where_clause of (Token.t (* "where" *) * constant_pattern)
]

and query_continuation = [
  `Rectype of (Token.t (* "into" *) * identifier * query_body)
]

and relational_pattern = [
    `LT_exp of (Token.t (* "<" *) * constant_pattern)
  | `LTEQ_exp of (Token.t (* "<=" *) * constant_pattern)
  | `GT_exp of (Token.t (* ">" *) * constant_pattern)
  | `GTEQ_exp of (Token.t (* ">=" *) * constant_pattern)
]

and return_type = [
    `Type of type_pattern
  | `Void_kw of Token.t (* "void" *)
]

and select_or_group_clause = [
    `Group_clause of (
        Token.t (* "group" *) * constant_pattern * Token.t (* "by" *)
      * constant_pattern
    )
  | `Select_clause of (Token.t (* "select" *) * constant_pattern)
]

and simple_assignment_expression = (
    identifier * Token.t (* "=" *) * constant_pattern
)

and simple_name = [
    `Gene_name of (identifier * type_argument_list)
  | `Choice_global of identifier_or_global
]

and statement = [
    `Blk of block
  | `Brk_stmt of (Token.t (* "break" *) * Token.t (* ";" *))
  | `Chec_stmt of (
        [
            `Chec of Token.t (* "checked" *)
          | `Unch of Token.t (* "unchecked" *)
        ]
      * block
    )
  | `Cont_stmt of (Token.t (* "continue" *) * Token.t (* ";" *))
  | `Do_stmt of (
        Token.t (* "do" *) * global_statement * Token.t (* "while" *)
      * Token.t (* "(" *) * constant_pattern * Token.t (* ")" *)
      * Token.t (* ";" *)
    )
  | `Empty_stmt of Token.t (* ";" *)
  | `Exp_stmt of expression_statement
  | `Fixed_stmt of (
        Token.t (* "fixed" *) * Token.t (* "(" *) * variable_declaration
      * Token.t (* ")" *) * global_statement
    )
  | `For_each_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "foreach" *)
      * Token.t (* "(" *)
      * [
            `Type_choice_id of (type_pattern * anon_choice_id_bf14316)
          | `Exp of constant_pattern
        ]
      * Token.t (* "in" *)
      * constant_pattern
      * Token.t (* ")" *)
      * global_statement
    )
  | `For_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * [
            `Var_decl of variable_declaration
          | `Exp_rep_COMMA_exp of (
                constant_pattern
              * interpolation_alignment_clause list (* zero or more *)
            )
        ]
          option
      * Token.t (* ";" *)
      * constant_pattern option
      * Token.t (* ";" *)
      * anon_opt_cst_pat_rep_interp_alig_clause_080fdff
      * Token.t (* ")" *)
      * global_statement
    )
  | `Goto_stmt of (
        Token.t (* "goto" *)
      * [
            `Id of identifier
          | `Case_exp of (Token.t (* "case" *) * constant_pattern)
          | `Defa of Token.t (* "default" *)
        ]
      * Token.t (* ";" *)
    )
  | `If_stmt of (
        Token.t (* "if" *)
      * Token.t (* "(" *)
      * constant_pattern
      * Token.t (* ")" *)
      * global_statement
      * (Token.t (* "else" *) * global_statement) option
    )
  | `Labe_stmt of (identifier * Token.t (* ":" *) * global_statement)
  | `Local_decl_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "using" *) option
      * modifier list (* zero or more *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Local_func_stmt of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * return_type
      * identifier
      * type_parameter_list option
      * parameter_list
      * type_parameter_constraints_clause list (* zero or more *)
      * function_body
    )
  | `Lock_stmt of (
        Token.t (* "lock" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *) * global_statement
    )
  | `Ret_stmt of (
        Token.t (* "return" *)
      * constant_pattern option
      * Token.t (* ";" *)
    )
  | `Switch_stmt of (
        Token.t (* "switch" *)
      * [
            `LPAR_exp_RPAR of parenthesized_expression
          | `Tuple_exp of tuple_expression
        ]
      * switch_body
    )
  | `Throw_stmt of (
        Token.t (* "throw" *)
      * constant_pattern option
      * Token.t (* ";" *)
    )
  | `Try_stmt of (
        Token.t (* "try" *)
      * block
      * catch_clause list (* zero or more *)
      * finally_clause option
    )
  | `Unsafe_stmt of (Token.t (* "unsafe" *) * block)
  | `Using_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "using" *)
      * Token.t (* "(" *)
      * [ `Var_decl of variable_declaration | `Exp of constant_pattern ]
      * Token.t (* ")" *)
      * global_statement
    )
  | `While_stmt of (
        Token.t (* "while" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *) * global_statement
    )
  | `Yield_stmt of (
        Token.t (* "yield" *)
      * [
            `Ret_exp of (Token.t (* "return" *) * constant_pattern)
          | `Brk of Token.t (* "break" *)
        ]
      * Token.t (* ";" *)
    )
]

and subpattern = (name_colon option * pattern)

and switch_body = (
    Token.t (* "{" *)
  * switch_section list (* zero or more *)
  * Token.t (* "}" *)
)

and switch_expression_arm = (
    pattern
  * when_clause option
  * Token.t (* "=>" *)
  * constant_pattern
)

and switch_section = (
    [
        `Case_switch_label of case_switch_label
      | `Case_pat_switch_label of case_pattern_switch_label
      | `Defa_switch_label of default_switch_label
    ]
      list (* one or more *)
  * global_statement list (* one or more *)
)

and tuple_element = (type_pattern * identifier option)

and tuple_expression = (
    Token.t (* "(" *)
  * argument
  * (Token.t (* "," *) * argument) list (* one or more *)
  * Token.t (* ")" *)
)

and type_ = [
    `Impl_type of Token.t (* "var" *)
  | `Array_type of array_type
  | `Name of name
  | `Null_type of nullable_type
  | `Poin_type of (type_pattern * Token.t (* "*" *))
  | `Func_poin_type of (
        Token.t (* "delegate" *)
      * Token.t (* "*" *)
      * function_pointer_calling_convention option
      * Token.t (* "<" *)
      * function_pointer_parameter
      * (Token.t (* "," *) * function_pointer_parameter)
          list (* zero or more *)
      * Token.t (* ">" *)
    )
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of (
        Token.t (* "(" *)
      * tuple_element
      * Token.t (* "," *)
      * tuple_element
      * (Token.t (* "," *) * tuple_element) list (* zero or more *)
      * Token.t (* ")" *)
    )
]

and type_argument_list = (
    Token.t (* "<" *)
  * [
        `Rep_COMMA of Token.t (* "," *) list (* zero or more *)
      | `Type_rep_COMMA_type of (
            type_pattern
          * (Token.t (* "," *) * type_pattern) list (* zero or more *)
        )
    ]
  * Token.t (* ">" *)
)

and type_constraint = type_

and type_parameter = (
    attribute_list list (* zero or more *)
  * [ `In of Token.t (* "in" *) | `Out of Token.t (* "out" *) ] option
  * identifier
)

and type_parameter_constraint = [
    `Class_opt_QMARK of (Token.t (* "class" *) * Token.t (* "?" *) option)
  | `Struct of Token.t (* "struct" *)
  | `Notn of Token.t (* "notnull" *)
  | `Unma of Token.t (* "unmanaged" *)
  | `Cons_cons of (
        Token.t (* "new" *) * Token.t (* "(" *) * Token.t (* ")" *)
    )
  | `Type_cons of type_constraint
]

and type_parameter_constraints_clause = (
    Token.t (* "where" *)
  * identifier_or_global
  * Token.t (* ":" *)
  * type_parameter_constraint
  * (Token.t (* "," *) * type_parameter_constraint) list (* zero or more *)
)

and type_parameter_list = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* ">" *)
)

and type_pattern = type_

and variable_declaration = (
    type_pattern
  * variable_declarator
  * (Token.t (* "," *) * variable_declarator) list (* zero or more *)
)

and variable_declarator = (
    anon_choice_id_bf14316
  * element_binding_expression option
  * equals_value_clause option
)

and when_clause = (Token.t (* "when" *) * constant_pattern)

and with_initializer_expression = (
    simple_assignment_expression
  * (Token.t (* "," *) * simple_assignment_expression)
      list (* zero or more *)
)
[@@deriving sexp_of]

type global_attribute_list = (
    Token.t (* "[" *)
  * [ `Asse of Token.t (* "assembly" *) | `Module of Token.t (* "module" *) ]
  * Token.t (* ":" *)
  * (attribute * (Token.t (* "," *) * attribute) list (* zero or more *))
      option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type primary_constructor_base_type = (identifier * argument_list)
[@@deriving sexp_of]

type bracketed_parameter_list = (
    Token.t (* "[" *)
  * parameter
  * (Token.t (* "," *) * parameter) list (* zero or more *)
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type enum_member_declaration = (
    attribute_list list (* zero or more *)
  * identifier
  * equals_value_clause option
)
[@@deriving sexp_of]

type using_directive = (
    Token.t (* "using" *)
  * [ `Static of Token.t (* "static" *) | `Name_equals of name_equals ]
      option
  * name
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type delegate_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "delegate" *)
  * return_type
  * identifier
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type base_list = (
    Token.t (* ":" *)
  * type_pattern
  * (Token.t (* "," *) * type_pattern) list (* zero or more *)
)
[@@deriving sexp_of]

type explicit_interface_specifier = (name * Token.t (* "." *))
[@@deriving sexp_of]

type accessor_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * [
        `Get of Token.t (* "get" *)
      | `Set of Token.t (* "set" *)
      | `Add of Token.t (* "add" *)
      | `Remove of Token.t (* "remove" *)
      | `Init of Token.t (* "init" *)
      | `Id of identifier
    ]
  * function_body
)
[@@deriving sexp_of]

type constructor_initializer = (
    Token.t (* ":" *)
  * [ `Base of Token.t (* "base" *) | `This of Token.t (* "this" *) ]
  * argument_list
)
[@@deriving sexp_of]

type record_base = [
    `COLON_id_rep_COMMA_id of (
        Token.t (* ":" *)
      * identifier
      * (Token.t (* "," *) * identifier) list (* zero or more *)
    )
  | `COLON_prim_cons_base_type_opt_COMMA_id_rep_COMMA_id of (
        Token.t (* ":" *)
      * primary_constructor_base_type
      * (
            Token.t (* "," *)
          * identifier
          * (Token.t (* "," *) * identifier) list (* zero or more *)
        )
          option
    )
]
[@@deriving sexp_of]

type enum_member_declaration_list = (
    Token.t (* "{" *)
  * (
        enum_member_declaration
      * (Token.t (* "," *) * enum_member_declaration) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type accessor_list = (
    Token.t (* "{" *)
  * accessor_declaration list (* zero or more *)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type enum_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "enum" *)
  * identifier
  * base_list option
  * enum_member_declaration_list
  * Token.t (* ";" *) option
)
[@@deriving sexp_of]

type class_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "class" *)
  * identifier
  * type_parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * Token.t (* ";" *) option
)

and declaration = [
    `Class_decl of class_declaration
  | `Cons_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * identifier
      * parameter_list
      * constructor_initializer option
      * function_body
    )
  | `Conv_op_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * [
            `Impl of Token.t (* "implicit" *)
          | `Expl of Token.t (* "explicit" *)
        ]
      * Token.t (* "operator" *)
      * type_pattern
      * parameter_list
      * function_body
    )
  | `Dele_decl of delegate_declaration
  | `Dest_decl of (
        attribute_list list (* zero or more *)
      * Token.t (* "extern" *) option
      * Token.t (* "~" *)
      * identifier
      * parameter_list
      * function_body
    )
  | `Enum_decl of enum_declaration
  | `Event_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "event" *)
      * type_pattern
      * explicit_interface_specifier option
      * identifier
      * [ `Acce_list of accessor_list | `SEMI of Token.t (* ";" *) ]
    )
  | `Event_field_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "event" *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Field_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Inde_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * explicit_interface_specifier option
      * Token.t (* "this" *)
      * bracketed_parameter_list
      * [
            `Acce_list of accessor_list
          | `Arrow_exp_clause_SEMI of (
                arrow_expression_clause * Token.t (* ";" *)
            )
        ]
    )
  | `Inte_decl of interface_declaration
  | `Meth_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * return_type
      * explicit_interface_specifier option
      * identifier
      * type_parameter_list option
      * parameter_list
      * type_parameter_constraints_clause list (* zero or more *)
      * function_body
    )
  | `Name_decl of namespace_declaration
  | `Op_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * Token.t (* "operator" *)
      * overloadable_operator
      * parameter_list
      * function_body
    )
  | `Prop_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_pattern
      * explicit_interface_specifier option
      * identifier
      * [
            `Acce_list_opt_EQ_exp_SEMI of (
                accessor_list
              * (Token.t (* "=" *) * constant_pattern * Token.t (* ";" *))
                  option
            )
          | `Arrow_exp_clause_SEMI of (
                arrow_expression_clause * Token.t (* ";" *)
            )
        ]
    )
  | `Record_decl of record_declaration
  | `Struct_decl of struct_declaration
  | `Using_dire of using_directive
  | `Ellips of Token.t (* "..." *)
]

and declaration_list = (
    Token.t (* "{" *)
  * declaration list (* zero or more *)
  * Token.t (* "}" *)
)

and interface_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "interface" *)
  * identifier
  * type_parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * Token.t (* ";" *) option
)

and namespace_declaration = (
    Token.t (* "namespace" *)
  * name
  * declaration_list
  * Token.t (* ";" *) option
)

and record_body = [
    `Decl_list of declaration_list
  | `SEMI of Token.t (* ";" *)
]

and record_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "record" *)
  * identifier
  * type_parameter_list option
  * parameter_list option
  * record_base option
  * type_parameter_constraints_clause list (* zero or more *)
  * record_body
)

and struct_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "struct" *)
  * identifier
  * type_parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * Token.t (* ";" *) option
)
[@@deriving sexp_of]

type type_declaration = [
    `Class_decl of class_declaration
  | `Struct_decl of struct_declaration
  | `Inte_decl of interface_declaration
  | `Enum_decl of enum_declaration
  | `Dele_decl of delegate_declaration
  | `Record_decl of record_declaration
]
[@@deriving sexp_of]

type namespace_member_declaration = [
    `Name_decl of namespace_declaration
  | `Type_decl of type_declaration
]
[@@deriving sexp_of]

type compilation_unit = [
    `Rep_extern_alias_dire_rep_using_dire_rep_global_attr_list_rep_global_stmt_rep_name_member_decl of (
        extern_alias_directive list (* zero or more *)
      * using_directive list (* zero or more *)
      * global_attribute_list list (* zero or more *)
      * global_statement list (* zero or more *)
      * namespace_member_declaration list (* zero or more *)
    )
  | `Semg_exp of (Token.t (* "__SEMGREP_EXPRESSION" *) * constant_pattern)
]
[@@deriving sexp_of]

type constructor_constraint (* inlined *) = (
    Token.t (* "new" *) * Token.t (* "(" *) * Token.t (* ")" *)
)
[@@deriving sexp_of]

type empty_statement (* inlined *) = Token.t (* ";" *)
[@@deriving sexp_of]

type implicit_type (* inlined *) = Token.t (* "var" *)
[@@deriving sexp_of]

type ellipsis (* inlined *) = Token.t (* "..." *)
[@@deriving sexp_of]

type void_keyword (* inlined *) = Token.t (* "void" *)
[@@deriving sexp_of]

type else_directive (* inlined *) = Token.t (* "else" *)
[@@deriving sexp_of]

type global (* inlined *) = Token.t (* "global" *)
[@@deriving sexp_of]

type null_literal (* inlined *) = Token.t (* "null" *)
[@@deriving sexp_of]

type continue_statement (* inlined *) = (
    Token.t (* "continue" *) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type discard (* inlined *) = Token.t (* "_" *)
[@@deriving sexp_of]

type this_expression (* inlined *) = Token.t (* "this" *)
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type endif_directive (* inlined *) = Token.t (* "endif" *)
[@@deriving sexp_of]

type base_expression (* inlined *) = Token.t (* "base" *)
[@@deriving sexp_of]

type break_statement (* inlined *) = (
    Token.t (* "break" *) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type character_literal (* inlined *) = (
    Token.t (* "'" *)
  * [
        `Imm_tok_pat_684220d of imm_tok_pat_684220d (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
    ]
  * Token.t (* "'" *)
)
[@@deriving sexp_of]

type string_literal (* inlined *) = (
    Token.t (* "\"" *)
  * [
        `Str_lit_frag of string_literal_fragment (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
    ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)
[@@deriving sexp_of]

type preproc_parenthesized_expression (* inlined *) = (
    Token.t (* "(" *) * preproc_expression * Token.t (* ")" *)
)
[@@deriving sexp_of]

type preproc_unary_expression (* inlined *) = (
    Token.t (* "!" *) * preproc_expression
)
[@@deriving sexp_of]

type parenthesized_variable_designation (* inlined *) = (
    Token.t (* "(" *)
  * (
        variable_designation
      * (Token.t (* "," *) * variable_designation) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type var_pattern (* inlined *) = (Token.t (* "var" *) * variable_designation)
[@@deriving sexp_of]

type preprocessor_call (* inlined *) = (
    preproc_directive_start (*tok*)
  * [
        `Null_dire of nullable_directive
      | `Define_dire of define_directive
      | `Undef_dire of undef_directive
      | `If_dire of if_directive
      | `Else_dire of Token.t (* "else" *)
      | `Elif_dire of elif_directive
      | `Endif_dire of Token.t (* "endif" *)
      | `Region_dire of region_directive
      | `Endr_dire of endregion_directive
      | `Error_dire of error_directive
      | `Warn_dire of warning_directive
      | `Line_dire of line_directive
      | `Pragma_dire of pragma_directive
    ]
  * preproc_directive_end (*tok*)
)
[@@deriving sexp_of]

type alias_qualified_name (* inlined *) = (
    identifier_or_global * Token.t (* "::" *) * simple_name
)
[@@deriving sexp_of]

type anonymous_method_expression (* inlined *) = (
    Token.t (* "async" *) option
  * Token.t (* "delegate" *)
  * parameter_list option
  * block
)
[@@deriving sexp_of]

type anonymous_object_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * Token.t (* "{" *)
  * (
        anonymous_object_member_declarator
      * (Token.t (* "," *) * anonymous_object_member_declarator)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type array_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * array_type
  * initializer_expression option
)
[@@deriving sexp_of]

type as_expression (* inlined *) = (
    constant_pattern * Token.t (* "as" *) * type_pattern
)
[@@deriving sexp_of]

type assignment_expression (* inlined *) = (
    constant_pattern * assignment_operator * constant_pattern
)
[@@deriving sexp_of]

type await_expression (* inlined *) = (
    Token.t (* "await" *) * constant_pattern
)
[@@deriving sexp_of]

type cast_expression (* inlined *) = (
    Token.t (* "(" *) * type_pattern * Token.t (* ")" *) * constant_pattern
)
[@@deriving sexp_of]

type checked_statement (* inlined *) = (
    [ `Chec of Token.t (* "checked" *) | `Unch of Token.t (* "unchecked" *) ]
  * block
)
[@@deriving sexp_of]

type conditional_access_expression (* inlined *) = (
    constant_pattern
  * Token.t (* "?" *)
  * [
        `Member_bind_exp of member_binding_expression
      | `Elem_bind_exp of element_binding_expression
    ]
)
[@@deriving sexp_of]

type conditional_expression (* inlined *) = (
    constant_pattern * Token.t (* "?" *) * constant_pattern
  * Token.t (* ":" *) * constant_pattern
)
[@@deriving sexp_of]

type declaration_pattern (* inlined *) = (
    type_pattern * variable_designation
)
[@@deriving sexp_of]

type deep_ellipsis (* inlined *) = (
    Token.t (* "<..." *) * constant_pattern * Token.t (* "...>" *)
)
[@@deriving sexp_of]

type default_expression (* inlined *) = (
    Token.t (* "default" *)
  * (Token.t (* "(" *) * type_pattern * Token.t (* ")" *)) option
)
[@@deriving sexp_of]

type do_statement (* inlined *) = (
    Token.t (* "do" *) * global_statement * Token.t (* "while" *)
  * Token.t (* "(" *) * constant_pattern * Token.t (* ")" *)
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type element_access_expression (* inlined *) = (
    constant_pattern * element_binding_expression
)
[@@deriving sexp_of]

type fixed_statement (* inlined *) = (
    Token.t (* "fixed" *) * Token.t (* "(" *) * variable_declaration
  * Token.t (* ")" *) * global_statement
)
[@@deriving sexp_of]

type for_each_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "foreach" *)
  * Token.t (* "(" *)
  * [
        `Type_choice_id of (type_pattern * anon_choice_id_bf14316)
      | `Exp of constant_pattern
    ]
  * Token.t (* "in" *)
  * constant_pattern
  * Token.t (* ")" *)
  * global_statement
)
[@@deriving sexp_of]

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * [
        `Var_decl of variable_declaration
      | `Exp_rep_COMMA_exp of (
            constant_pattern
          * interpolation_alignment_clause list (* zero or more *)
        )
    ]
      option
  * Token.t (* ";" *)
  * constant_pattern option
  * Token.t (* ";" *)
  * anon_opt_cst_pat_rep_interp_alig_clause_080fdff
  * Token.t (* ")" *)
  * global_statement
)
[@@deriving sexp_of]

type function_pointer_type (* inlined *) = (
    Token.t (* "delegate" *)
  * Token.t (* "*" *)
  * function_pointer_calling_convention option
  * Token.t (* "<" *)
  * function_pointer_parameter
  * (Token.t (* "," *) * function_pointer_parameter) list (* zero or more *)
  * Token.t (* ">" *)
)
[@@deriving sexp_of]

type generic_name (* inlined *) = (identifier * type_argument_list)
[@@deriving sexp_of]

type goto_statement (* inlined *) = (
    Token.t (* "goto" *)
  * [
        `Id of identifier
      | `Case_exp of (Token.t (* "case" *) * constant_pattern)
      | `Defa of Token.t (* "default" *)
    ]
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type group_clause (* inlined *) = (
    Token.t (* "group" *) * constant_pattern * Token.t (* "by" *)
  * constant_pattern
)
[@@deriving sexp_of]

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * Token.t (* "(" *)
  * constant_pattern
  * Token.t (* ")" *)
  * global_statement
  * (Token.t (* "else" *) * global_statement) option
)
[@@deriving sexp_of]

type implicit_array_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * Token.t (* "[" *)
  * Token.t (* "," *) list (* zero or more *)
  * Token.t (* "]" *)
  * initializer_expression
)
[@@deriving sexp_of]

type implicit_object_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * argument_list
  * initializer_expression option
)
[@@deriving sexp_of]

type implicit_stack_alloc_array_creation_expression (* inlined *) = (
    Token.t (* "stackalloc" *) * Token.t (* "[" *) * Token.t (* "]" *)
  * initializer_expression
)
[@@deriving sexp_of]

type invocation_expression (* inlined *) = (constant_pattern * argument_list)
[@@deriving sexp_of]

type is_expression (* inlined *) = (
    constant_pattern * Token.t (* "is" *) * type_pattern
)
[@@deriving sexp_of]

type is_pattern_expression (* inlined *) = (
    constant_pattern * Token.t (* "is" *) * pattern
)
[@@deriving sexp_of]

type join_clause (* inlined *) = (
    Token.t (* "join" *)
  * type_pattern option
  * identifier
  * Token.t (* "in" *)
  * constant_pattern
  * Token.t (* "on" *)
  * constant_pattern
  * Token.t (* "equals" *)
  * constant_pattern
  * join_into_clause option
)
[@@deriving sexp_of]

type labeled_statement (* inlined *) = (
    identifier * Token.t (* ":" *) * global_statement
)
[@@deriving sexp_of]

type lambda_expression (* inlined *) = (
    Token.t (* "async" *) option
  * Token.t (* "static" *) option
  * [ `Param_list of parameter_list | `Id of identifier ]
  * Token.t (* "=>" *)
  * [ `Blk of block | `Exp of constant_pattern ]
)
[@@deriving sexp_of]

type let_clause (* inlined *) = (
    Token.t (* "let" *) * identifier * Token.t (* "=" *) * constant_pattern
)
[@@deriving sexp_of]

type local_declaration_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "using" *) option
  * modifier list (* zero or more *)
  * variable_declaration
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type local_function_statement (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * return_type
  * identifier
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * function_body
)
[@@deriving sexp_of]

type lock_statement (* inlined *) = (
    Token.t (* "lock" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* ")" *) * global_statement
)
[@@deriving sexp_of]

type make_ref_expression (* inlined *) = (
    Token.t (* "__makeref" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type member_access_ellipsis_expression (* inlined *) = (
    anon_choice_cst_pat_3bb8381 * anon_choice_DOT_2ad1dab
  * Token.t (* "..." *)
)
[@@deriving sexp_of]

type member_access_expression (* inlined *) = (
    anon_choice_cst_pat_3bb8381 * anon_choice_DOT_2ad1dab * simple_name
)
[@@deriving sexp_of]

type negated_pattern (* inlined *) = (Token.t (* "not" *) * pattern)
[@@deriving sexp_of]

type object_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * type_pattern
  * argument_list option
  * initializer_expression option
)
[@@deriving sexp_of]

type order_by_clause (* inlined *) = (
    Token.t (* "orderby" *)
  * ordering
  * (Token.t (* "," *) * ordering) list (* zero or more *)
)
[@@deriving sexp_of]

type parameter_array (* inlined *) = (
    attribute_list list (* zero or more *)
  * Token.t (* "params" *)
  * [ `Array_type of array_type | `Null_type of nullable_type ]
  * identifier
)
[@@deriving sexp_of]

type parenthesized_pattern (* inlined *) = (
    Token.t (* "(" *) * pattern * Token.t (* ")" *)
)
[@@deriving sexp_of]

type pointer_type (* inlined *) = (type_pattern * Token.t (* "*" *))
[@@deriving sexp_of]

type qualified_name (* inlined *) = (name * Token.t (* "." *) * simple_name)
[@@deriving sexp_of]

type query_expression (* inlined *) = (from_clause * query_body)
[@@deriving sexp_of]

type range_expression (* inlined *) = (
    constant_pattern option
  * Token.t (* ".." *)
  * constant_pattern option
)
[@@deriving sexp_of]

type recursive_pattern (* inlined *) = (
    type_pattern option
  * [
        `Posi_pat_clause_opt_prop_pat_clause of (
            positional_pattern_clause
          * property_pattern_clause option
        )
      | `Prop_pat_clause of property_pattern_clause
    ]
  * variable_designation option
)
[@@deriving sexp_of]

type ref_expression (* inlined *) = (Token.t (* "ref" *) * constant_pattern)
[@@deriving sexp_of]

type ref_type_expression (* inlined *) = (
    Token.t (* "__reftype" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type ref_value_expression (* inlined *) = (
    Token.t (* "__refvalue" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* "," *) * type_pattern * Token.t (* ")" *)
)
[@@deriving sexp_of]

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * constant_pattern option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type select_clause (* inlined *) = (
    Token.t (* "select" *) * constant_pattern
)
[@@deriving sexp_of]

type size_of_expression (* inlined *) = (
    Token.t (* "sizeof" *) * Token.t (* "(" *) * type_pattern
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type stack_alloc_array_creation_expression (* inlined *) = (
    Token.t (* "stackalloc" *)
  * array_type
  * initializer_expression option
)
[@@deriving sexp_of]

type switch_expression (* inlined *) = (
    constant_pattern
  * Token.t (* "switch" *)
  * Token.t (* "{" *)
  * (
        switch_expression_arm
      * (Token.t (* "," *) * switch_expression_arm) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type switch_statement (* inlined *) = (
    Token.t (* "switch" *)
  * [
        `LPAR_exp_RPAR of parenthesized_expression
      | `Tuple_exp of tuple_expression
    ]
  * switch_body
)
[@@deriving sexp_of]

type throw_expression (* inlined *) = (
    Token.t (* "throw" *) * constant_pattern
)
[@@deriving sexp_of]

type throw_statement (* inlined *) = (
    Token.t (* "throw" *)
  * constant_pattern option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * block
  * catch_clause list (* zero or more *)
  * finally_clause option
)
[@@deriving sexp_of]

type tuple_type (* inlined *) = (
    Token.t (* "(" *)
  * tuple_element
  * Token.t (* "," *)
  * tuple_element
  * (Token.t (* "," *) * tuple_element) list (* zero or more *)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type type_of_expression (* inlined *) = (
    Token.t (* "typeof" *) * Token.t (* "(" *) * type_pattern
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type unsafe_statement (* inlined *) = (Token.t (* "unsafe" *) * block)
[@@deriving sexp_of]

type using_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "using" *)
  * Token.t (* "(" *)
  * [ `Var_decl of variable_declaration | `Exp of constant_pattern ]
  * Token.t (* ")" *)
  * global_statement
)
[@@deriving sexp_of]

type where_clause (* inlined *) = (Token.t (* "where" *) * constant_pattern)
[@@deriving sexp_of]

type while_statement (* inlined *) = (
    Token.t (* "while" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* ")" *) * global_statement
)
[@@deriving sexp_of]

type with_expression (* inlined *) = (
    constant_pattern
  * Token.t (* "with" *)
  * Token.t (* "{" *)
  * with_initializer_expression option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type yield_statement (* inlined *) = (
    Token.t (* "yield" *)
  * [
        `Ret_exp of (Token.t (* "return" *) * constant_pattern)
      | `Brk of Token.t (* "break" *)
    ]
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type destructor_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * Token.t (* "extern" *) option
  * Token.t (* "~" *)
  * identifier
  * parameter_list
  * function_body
)
[@@deriving sexp_of]

type conversion_operator_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * [ `Impl of Token.t (* "implicit" *) | `Expl of Token.t (* "explicit" *) ]
  * Token.t (* "operator" *)
  * type_pattern
  * parameter_list
  * function_body
)
[@@deriving sexp_of]

type operator_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * Token.t (* "operator" *)
  * overloadable_operator
  * parameter_list
  * function_body
)
[@@deriving sexp_of]

type field_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * variable_declaration
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type ref_type (* inlined *) = (
    Token.t (* "ref" *)
  * Token.t (* "readonly" *) option
  * type_pattern
)
[@@deriving sexp_of]

type semgrep_expression (* inlined *) = (
    Token.t (* "__SEMGREP_EXPRESSION" *) * constant_pattern
)
[@@deriving sexp_of]

type event_field_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "event" *)
  * variable_declaration
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type method_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * return_type
  * explicit_interface_specifier option
  * identifier
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * function_body
)
[@@deriving sexp_of]

type constructor_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * identifier
  * parameter_list
  * constructor_initializer option
  * function_body
)
[@@deriving sexp_of]

type event_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "event" *)
  * type_pattern
  * explicit_interface_specifier option
  * identifier
  * [ `Acce_list of accessor_list | `SEMI of Token.t (* ";" *) ]
)
[@@deriving sexp_of]

type indexer_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * explicit_interface_specifier option
  * Token.t (* "this" *)
  * bracketed_parameter_list
  * [
        `Acce_list of accessor_list
      | `Arrow_exp_clause_SEMI of (
            arrow_expression_clause * Token.t (* ";" *)
        )
    ]
)
[@@deriving sexp_of]

type property_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_pattern
  * explicit_interface_specifier option
  * identifier
  * [
        `Acce_list_opt_EQ_exp_SEMI of (
            accessor_list
          * (Token.t (* "=" *) * constant_pattern * Token.t (* ";" *)) option
        )
      | `Arrow_exp_clause_SEMI of (
            arrow_expression_clause * Token.t (* ";" *)
        )
    ]
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_compilation_unit root
  |> Print_sexp.to_stdout
